<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhengzeqin&#39;s blogs</title>
  
  <subtitle>Lightly do not say gives up, otherwise sorry oneself</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhengzeqin.netlify.app/"/>
  <updated>2020-08-25T02:36:34.364Z</updated>
  <id>https://zhengzeqin.netlify.app/</id>
  
  <author>
    <name>zhengzeqin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初尝-Flutter-与-Native-混合开发-FlutterBoost-应用</title>
    <link href="https://zhengzeqin.netlify.app/2020/08/25/%E5%88%9D%E5%B0%9D-Flutter-%E4%B8%8E-Native-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91-FlutterBoost-%E5%BA%94%E7%94%A8/"/>
    <id>https://zhengzeqin.netlify.app/2020/08/25/%E5%88%9D%E5%B0%9D-Flutter-%E4%B8%8E-Native-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91-FlutterBoost-%E5%BA%94%E7%94%A8/</id>
    <published>2020-08-25T02:36:34.364Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在跨平台开发中 <code>Flutter</code> 优势很明了，简单总结 : <br></p><ol><li>接近原生的性能  </li><li>热重载  </li><li>丰富的组件<br><br>考虑项目有大量原生业务，我们也不可能基于 Flutter 重构所有的业务。<br>因此只能在原有的基础上混合使用 Flutter 来开发新业务或重构旧业务。<br>参考闲鱼，哈罗等，他们也提供相应的解决混合开发方案 <a href="https://github.com/alibaba/flutter_boost" target="_blank" rel="noopener">flutter_boost</a> 和 <a href="https://github.com/hellobike/flutter_thrio" target="_blank" rel="noopener">flutter_thrio</a>。 <br>目前我们采用 flutter_boost 作为我们 tw591 项目的解决方案。</li></ol></blockquote><h2 id="Flutter-混编现有项目"><a href="#Flutter-混编现有项目" class="headerlink" title="Flutter 混编现有项目"></a>Flutter 混编现有项目</h2><blockquote><p>正式接入：</p></blockquote><ol><li><p>创建 Flutter 项目<code>flutter create -t module flutter_module</code>, 建议创建完可以执行用 AndoirdStudio 编译执行，看是否正常,不过记得删除生成的ios 文件，否则会遇第4条说的flutter_export_environment 问题</p></li><li><p>将创建的 flutter_module 项目到自己目标仓库中</p></li><li><p>在 Podfile 文件添加如下脚本</p></li></ol><pre><code>// 注意：这个指定路径即是你的 flutter_module 项目的目标路径flutter_application_path = &#39;../../TWFlutter591/flutter_module&#39;load File.join(flutter_application_path, &#39;.ios&#39;, &#39;Flutter&#39;, &#39;podhelper.rb&#39;)target &#39;twhouse&#39; doinstall_all_flutter_pods(flutter_application_path)end</code></pre><ol start="4"><li>注意项目报 flutter_export_environment.sh 文件路径错误<blockquote><p>处理方式是删除flutter_module/ios 文件<br>用AndoirdStudio 或者 VSCode 运行一遍，产生新的 flutter_export_environment.sh 文件</p></blockquote></li></ol><p><img src="/images/2020/%E5%88%9D%E5%B0%9D-Flutter-%E4%B8%8E-Native-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91-FlutterBoost-%E5%BA%94%E7%94%A8/1.png" alt="" loading="lazy"></p><ol start="5"><li>集成闲鱼 flutter_boost 混合开发方案</li></ol><ul><li>注意：flutter_boost 版本需要和我们 flutter 版本对应，例如：flutter_boost:v1.17.1-hotfixes 对应的flutter sdk：1.17.1 </li><li>使用 Flutter –version 命令查看当前版本</li><li>打开 flutter_module 文件夹 下pubspec.yaml 文件，添加依赖<pre><code>flutter_boost:  git:      url: &#39;https://github.com/alibaba/flutter_boost.git&#39;      ref: &#39;v1.17.1-hotfixes&#39;</code></pre></li><li>执行命令 <code>flutter packages get</code></li><li>最后在项目中执行 <code>pod install --repo-update</code></li></ul><p><img src="/images/2020/%E5%88%9D%E5%B0%9D-Flutter-%E4%B8%8E-Native-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91-FlutterBoost-%E5%BA%94%E7%94%A8/2.png" alt="" loading="lazy"></p><ul><li>执行 install 后原生项目 Flutter 目录，会将我们 Flutter 项目打包成 framework</li></ul><p><img src="/images/2020/%E5%88%9D%E5%B0%9D-Flutter-%E4%B8%8E-Native-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91-FlutterBoost-%E5%BA%94%E7%94%A8/3.png" alt="" loading="lazy"></p><h2 id="Native-部分"><a href="#Native-部分" class="headerlink" title="Native 部分"></a>Native 部分</h2><p><img src="/images/2020/%E5%88%9D%E5%B0%9D-Flutter-%E4%B8%8E-Native-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91-FlutterBoost-%E5%BA%94%E7%94%A8/4.png" alt="" loading="lazy"></p><blockquote><ul><li>TWFlutterUtil 单例类用来注册 flutter 引擎，同时封装一层调用，避免 FlutterBoostPlugin 直接调用</li><li>TWFlutterPlatformRouter 基于 Flutter_boost DEMO 提供的基础上，根据我们项目业务做了调整，主要是 flutter 与 Native 平台交互的 Router</li><li>TWFlutterJumpUtil 主要是处理 Flutter 与 Native 相互路由跳转间的业务逻辑</li><li>TWFlutterNativePageName 定义页面路由名称</li><li>TWFlutterNativeEventUtil 主要是处理 Flutter 与 Native 事件的业务逻辑</li></ul></blockquote><h3 id="示例-TWFlutterUtil-部分"><a href="#示例-TWFlutterUtil-部分" class="headerlink" title="示例 TWFlutterUtil 部分"></a>示例 TWFlutterUtil 部分</h3><blockquote><p><code>TWFlutterUtil.swift</code>    </p></blockquote><pre><code class="swift">import UIKitimport flutter_boost@objcMembers class TWFlutterUtil: NSObject {    static let shareInstance = TWFlutterUtil()    var router: TWFlutterPlatformRouter?    var engine: FlutterEngine?    /// 注册 flutter 引擎    func registerFlutter() {        router = TWFlutterPlatformRouter()        guard let router = router else {return}        FlutterBoostPlugin.sharedInstance().startFlutter(with: router) {[weak self](engine) in            self?.engine = engine            HouseTool.dispatch(afterTime: 2.0) {                TWFlutterNativeEventUtil.sendConfigureInfo()            }        }    }    // MARK: - sendEvent    /**     * Native层往Dart层发送事件，事件名称通过eventName指定     *     * @param eventName 事件名称     * @param arguments 参数     */    open class func sendEvent(_ eventName: String, arguments: [AnyHashable: Any]) {        FlutterBoostPlugin.sharedInstance().sendEvent(eventName, arguments: arguments)    }    /**    * 添加监听Dart层调用Native层的事件    *    * @param name 事件名称    * @param listner 事件监听器    */    open class func addEventListener(_ listener: @escaping FLBEventListener, name: String) -&gt; FLBVoidCallback {        return FlutterBoostPlugin.sharedInstance().addEventListener(listener, forName: name)    }    // MARK: - open/close Page    /**     * 关闭页面，混合栈推荐使用的用于操作页面的接口     *     * @param uniqueId 关闭的页面唯一ID符     * @param resultData 页面要返回的结果（给上一个页面），会作为页面返回函数的回调参数     * @param exts 额外参数     * @param completion 注意必传 关闭页面的即时回调，页面一旦关闭即回调     */    open class func close(_ uniqueId: String, result resultData: [AnyHashable: Any], exts: [AnyHashable: Any], completion: @escaping (Bool) -&gt; Void) {        FlutterBoostPlugin.close(uniqueId, result: resultData, exts: exts, completion: completion)    }    /**     * 打开新页面（默认以push方式），混合栈推荐使用的用于操作页面的接口；通过urlParams可以设置为以present方式打开页面：urlParams:@{@&quot;present&quot;:@(YES)}     *     * @param url 打开的页面资源定位符     * @param urlParams 传入页面的参数; 若有特殊逻辑，可以通过这个参数设置回调的id     * @param exts 额外参数     * @param resultCallback 当页面结束返回时执行的回调，通过这个回调可以取得页面的返回数据，如close函数传入的resultData     * @param completion 注意必传 打开页面的即时回调，页面一旦打开即回调     */    open class func open(_ url: String, urlParams: [AnyHashable: Any], exts: [AnyHashable: Any], onPageFinished resultCallback: @escaping ([AnyHashable: Any]) -&gt; Void, completion: @escaping (Bool) -&gt; Void) {        FlutterBoostPlugin.open(url, urlParams: urlParams, exts: exts, onPageFinished: resultCallback, completion: completion)    }    /**     * Present方式打开新页面，混合栈推荐使用的用于操作页面的接口     *     * @param url 打开的页面资源定位符     * @param urlParams 传入页面的参数; 若有特殊逻辑，可以通过这个参数设置回调的id     * @param exts 额外参数     * @param resultCallback 当页面结束返回时执行的回调，通过这个回调可以取得页面的返回数据，如close函数传入的resultData     * @param completion 注意必传 打开页面的即时回调，页面一旦打开即回调     */    open class func present(_ url: String, urlParams: [AnyHashable: Any], exts: [AnyHashable: Any], onPageFinished resultCallback: @escaping ([AnyHashable: Any]) -&gt; Void, completion: @escaping (Bool) -&gt; Void) {        FlutterBoostPlugin.present(url, urlParams: urlParams, exts: exts, onPageFinished: resultCallback, completion: completion)    }}</code></pre><h3 id="Native-打开-Flutter-页面"><a href="#Native-打开-Flutter-页面" class="headerlink" title="Native 打开 Flutter 页面"></a>Native 打开 Flutter 页面</h3><blockquote><p>页面采用文件 <code>page</code> <code>页面类名</code>，作为注册 id</p></blockquote><pre><code class="swift">//在 iOS 中 TWFlutterUtil 打开更多页面TWFlutterUtil.open(&quot;TWMorePage&quot;,                           urlParams: [&quot;isDebug&quot;:API_DEBUG == 1 ? &quot;1&quot; : &quot;0&quot;],                           exts: [&quot;isHideNavigationBar&quot;:&quot;1&quot;],                           onPageFinished: { (result) in        }) { (finish) in        }</code></pre><h2 id="Flutter-部分"><a href="#Flutter-部分" class="headerlink" title="Flutter 部分"></a>Flutter 部分</h2><p><img src="/images/2020/%E5%88%9D%E5%B0%9D-Flutter-%E4%B8%8E-Native-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91-FlutterBoost-%E5%BA%94%E7%94%A8/5.png" alt="" loading="lazy"></p><blockquote><ul><li>TWFlutterBoostPage 主要是 flutter 项目的入口页面</li><li>TWRouterBoost 用于注册原生调用 flutter 的路由</li><li>TWFlutterNativeEvent 用于 flutter 与 native 的事件处理</li><li>TWRouterFlutterNative 路由跳转业务逻辑处理</li></ul></blockquote><h3 id="示例-TWFlutterBoostPage-部分"><a href="#示例-TWFlutterBoostPage-部分" class="headerlink" title="示例 TWFlutterBoostPage 部分"></a>示例 TWFlutterBoostPage 部分</h3><blockquote><p><code>TWFlutterBoostPage</code></p></blockquote><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:flutter_boost/flutter_boost.dart&#39;;import &#39;package:flutter_module/common/tw_app_color.dart&#39;;import &#39;package:flutter_module/router/tw_router_boost.dart&#39;;class TWFlutterBoostPage extends StatefulWidget {  @override  _TWFlutterBoostAppState createState() =&gt; _TWFlutterBoostAppState();}class _TWFlutterBoostAppState extends State&lt;TWFlutterBoostApp&gt; {  @override  void initState() {    super.initState();    //初始化注册...    TWRouterBoost routerBoost  = TWRouterBoost();    routerBoost.registerRouter();  }  @override  Widget build(BuildContext context) {    return MaterialApp(        title: &#39;Flutter Boost example&#39;,        //（2）初始化路由        debugShowCheckedModeBanner: true,        theme: ThemeData(          primaryColor: TWAppColor.tw_ff7f00,          dividerColor: TWAppColor.tw_eeeeee,        ),        builder: FlutterBoost.init(postPush: _onRoutePushed),        home: Container(            color:Colors.white        ));  }  void _onRoutePushed(      String pageName,      String uniqueId,      Map&lt;String, dynamic&gt; params,      Route&lt;dynamic&gt; route,      Future&lt;dynamic&gt; _,      ) {  }}</code></pre><blockquote><p><code>TWRouterFlutterNative</code></p></blockquote><pre><code class="dart">import &#39;package:flutter_boost/flutter_boost.dart&#39;;import &#39;package:flutter_module/features/mine/more/tw_more_page.dart&#39;;class TWRouterFlutterNative {  ///************** Flutter to Naitive *******************/  static const String tw_flutterOpenNative = &#39;TWFlutterOpenNative&#39;;  ///************** Naitive to Flutter *******************/  static const String tw_flutterMorePage = &quot;TWMorePage&quot;;  /// 路由跳转逻辑处理 map  static Map&lt;String, PageBuilder&gt; routerPageBuilder = &lt;String, PageBuilder&gt;{    tw_flutterMorePage: (String pageName, Map&lt;String, dynamic&gt; params, String _) =&gt; TWMorePage(params: params,),  };}</code></pre><blockquote><p><code>TWRouterBoost</code></p></blockquote><pre><code class="dart">import &#39;package:flutter/material.dart&#39;;import &#39;package:flutter_boost/flutter_boost.dart&#39;;import &#39;package:flutter_module/router/tw_router_flutter_native.dart&#39;;import &#39;package:flutter_module/util/tw_log.dart&#39;;class TWRouterBoost extends NavigatorObserver{  // 初始化注册路由...  void registerRouter() {    FlutterBoost.singleton.registerPageBuilders(TWRouterFlutterNative.routerPageBuilder);    FlutterBoost.singleton.addBoostNavigatorObserver(this);  }  ///************** NavigatorObserver Method *******************/  void didPush(Route&lt;dynamic&gt; route, Route&lt;dynamic&gt; previousRoute) {    TWLog(&quot;flutterboost#didPush&quot;);  }  void didPop(Route&lt;dynamic&gt; route, Route&lt;dynamic&gt; previousRoute) {    TWLog(&quot;flutterboost#didPop&quot;);  }  void didRemove(Route&lt;dynamic&gt; route, Route&lt;dynamic&gt; previousRoute) {    TWLog(&quot;flutterboost#didRemove&quot;);  }  void didReplace({Route&lt;dynamic&gt; newRoute, Route&lt;dynamic&gt; oldRoute}) {    TWLog(&quot;flutterboost#didReplace&quot;);  }}</code></pre><blockquote><p>TWFlutterNativeEvent</p></blockquote><pre><code class="dart">import &#39;package:flutter_boost/flutter_boost.dart&#39;;import &#39;package:flutter_module/config/tw_configure.dart&#39;;import &#39;package:flutter_module/util/tw_log.dart&#39;;class TWFlutterNativeEvent {  ///************** Native 发送给 Flutter 事件名称 *******************/  static final String tw_flutterNativeEventConfigureInfo = &quot;EventConfigureInfo&quot;;  ///************** Flutter 发送给 Native 事件名称 *******************/  ///************** Native 发送给 Flutter 事件统一处理 *******************/  /// 监听启动配置信息  static void addConfigureInfo() {    TWLog(&quot;开始配置启动信息...&quot;);    FlutterBoost.singleton.channel.addEventListener(TWFlutterNativeEvent.tw_flutterNativeEventConfigureInfo,            (name, arguments) {          TWConfigure.singleton.configure(arguments);          return;        });  }}</code></pre><h3 id="Flutter-打开-Native-页面"><a href="#Flutter-打开-Native-页面" class="headerlink" title="Flutter 打开 Native 页面"></a>Flutter 打开 Native 页面</h3><blockquote><p>采用项目路由方式打开<br>注意：<code>TWFlutterOpenNative</code> 标识 ID ，即是标记从 Flutter 页面打开 Native 页面 ，打开 Native 页面路由 exts 字段<br>路由部分，建议是原来项目有的，统一Android 和 iOS 的路由规则标准，我们 iOS 采用 MGJRouter , Android 采用 ARouter。定义一套项目的路由 URL 标准</p></blockquote><pre><code class="dart">  ///************** Private Method *******************/  void clickAction(int index) {    TWLog(&quot;點擊 index = $index&quot;);    /// 打开评价，    String open_page_url = &quot;app:///xxxx/more_page?entrance=more_evalue&amp;pushAnimation=1&quot;;    /// 闲鱼库打开 原生api    FlutterBoost.singleton.open(TWRouterFlutterNative.tw_flutterOpenNative, exts: {      &quot;app_open_url&quot;: app_open_url    }).then((value) =&gt; print(&#39;call me when page is finished. did recieve native route result $value&#39;)); }</code></pre><blockquote><p>用 flutter 重构更多页面, 体验感觉和原生差不多</p></blockquote><p><img src="/images/2020/%E5%88%9D%E5%B0%9D-Flutter-%E4%B8%8E-Native-%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91-FlutterBoost-%E5%BA%94%E7%94%A8/6.png" alt="" loading="lazy"></p><h2 id="优秀的第三方库"><a href="#优秀的第三方库" class="headerlink" title="优秀的第三方库"></a>优秀的第三方库</h2><blockquote><p>为了减少与原生桥接，尽量让 Android 和 iOS 能公用一套，那么接下来要做的是一些基础设施建设了。包括 网络库，状态管理，图片缓存，数据缓存等…</p></blockquote><table><thead><tr><th>分类</th><th>地址</th><th>star</th></tr></thead><tbody><tr><td>网络库</td><td><a href="https://github.com/flutterchina/dio" target="_blank" rel="noopener">Dio</a></td><td>8.2k</td></tr><tr><td>状态管理</td><td><a href="https://github.com/felangel/bloc" target="_blank" rel="noopener">bloc</a></td><td>5.3k</td></tr><tr><td>状态管理</td><td><a href="https://github.com/rrousselGit/provider" target="_blank" rel="noopener">provider</a></td><td>2.8k</td></tr><tr><td>数据库</td><td><a href="https://github.com/tekartik/sqflite" target="_blank" rel="noopener">sqflite</a></td><td>1.8k</td></tr><tr><td>图片缓存库</td><td><a href="https://github.com/Baseflow/flutter_cached_network_image" target="_blank" rel="noopener">flutter_cached_network_image</a></td><td>1.4k</td></tr><tr><td>刷新控件</td><td><a href="https://github.com/xuelongqy/flutter_easyrefresh" target="_blank" rel="noopener">flutter_easyrefresh</a></td><td>2.2k</td></tr><tr><td>刷新控件</td><td><a href="https://github.com/peng8350/flutter_pulltorefresh" target="_blank" rel="noopener">flutter_pulltorefresh</a></td><td>1.6k</td></tr><tr><td>轮播</td><td><a href="https://github.com/best-flutter/flutter_swiper" target="_blank" rel="noopener">flutter_swiper</a></td><td>2.6k</td></tr><tr><td>本地通知</td><td><a href="https://github.com/MaikuB/flutter_local_notifications" target="_blank" rel="noopener">flutter_local_notifications</a></td><td>1.1k</td></tr><tr><td>Widgets</td><td><a href="https://github.com/flutterchina/flukit" target="_blank" rel="noopener">flukit</a></td><td>2.6k</td></tr><tr><td>Toast</td><td><a href="https://github.com/OpenFlutter/flutter_oktoast" target="_blank" rel="noopener">flutter_oktoast</a></td><td>288</td></tr><tr><td>Toast</td><td><a href="https://github.com/ponnamkarthik/FlutterToast" target="_blank" rel="noopener">FlutterToast</a></td><td>818</td></tr><tr><td>菜单</td><td><a href="https://github.com/letsar/flutter_slidable" target="_blank" rel="noopener">flutter_slidable</a></td><td>1.4k</td></tr><tr><td>地图</td><td><a href="https://github.com/best-flutter/flutter_amap" target="_blank" rel="noopener">flutter_amap</a></td><td>137</td></tr><tr><td>地图</td><td><a href="https://github.com/best-flutter/flutter_amap_location" target="_blank" rel="noopener">flutter_amap_location</a></td><td>249</td></tr><tr><td>调试工具</td><td><a href="https://github.com/learn-flutter-dev/flutter_flipperkit" target="_blank" rel="noopener">flutter_slidable</a></td><td>308</td></tr></tbody></table><h2 id="目前项目结构"><a href="#目前项目结构" class="headerlink" title="目前项目结构"></a>目前项目结构</h2><pre><code>flutter_module├──images #图片资源├──asset  #本地资源├──lib   #项目代码    ├── features    # 业务模块    |   ├── home    # 首页        |   ├── search  # 搜寻        |   ├── news     # 新闻        |   └── mine     # 我的    |       └──more # 更多 (例：更多页面)    |           ├── model     # 模型    |           ├── view     # 视图    |           ├── tool     # 工具        |           └── page     # 页面          |           ├── page        # 入口主页面    ├── common      # 通用组件,头文件,定义常量 (例：颜色常量)    ├── util        # 工具类,http工具,公共方法       ├── widgets     # 各种封装的可复用组件      ├── store       # 数据相关 缓存库等    ├── blocs       # 状态管理相关        ├── config      # 配置中心 (例：主题颜色，debug 线上切换方法等)    └── router      # 路由         └──  页面映射配置、observe 方法导出</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在跨平台开发中 &lt;code&gt;Flutter&lt;/code&gt; 优势很明了，简单总结 : &lt;br&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS开发老司机的神兵利器-效率工具</title>
    <link href="https://zhengzeqin.netlify.app/2020/07/01/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    <id>https://zhengzeqin.netlify.app/2020/07/01/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/</id>
    <published>2020-07-01T19:03:09.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>作为<code>iOS</code>开发老司机们，我们肯定有各种各样的开发利器，以追求着<code>最高效率</code>。<br><br> 此篇分享下我们常用的各种<code>神兵利器</code>。如果有朋友能推荐更好的欢迎补充，分享我！<a href="https://juejin.im/post/5efadbcf6fb9a07eae53f126" target="_blank" rel="noopener">文章地址</a></p></blockquote><h2 id="Mac-常用的工具集"><a href="#Mac-常用的工具集" class="headerlink" title="Mac 常用的工具集"></a>Mac 常用的工具集</h2><h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a><a href="https://github.com/sirius1024/iterm2-with-oh-my-zsh" target="_blank" rel="noopener">iTerm2</a></h3><blockquote><ul><li><code>iTerm2 + Oh My Zsh</code> 打造舒适终端体验 </li><li>功能：支持个性主题，高亮插件，可选择、命令补全等</li><li>命令补全功能方便我日常命令输入，有点回到日常IDE开发的感觉！<br>效果图如下</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_iTerm2.png" alt="" loading="lazy"></p><h3 id="ssh-工具-shuttle"><a href="#ssh-工具-shuttle" class="headerlink" title="ssh 工具 shuttle"></a><a href="https://github.com/fitztrev/shuttle" target="_blank" rel="noopener">ssh 工具 shuttle</a></h3><blockquote><p>方便我们将日常终端命令集成到 <code>shuttle</code> 中，方便快速执行命令</p><ul><li>工作中用它执行shh终端命令，远程链接屏幕，以及自动打包等构建命令</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_shuttle.jpg" alt="" loading="lazy"></p><h3 id="uTools"><a href="#uTools" class="headerlink" title="uTools"></a><a href="https://www.u.tools/" target="_blank" rel="noopener">uTools</a></h3><blockquote><ul><li><code>uTools</code> 是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。</li><li>上面有方便开发人员使用各种各样的插件，比如解码编码器，json编码器，以及各种开发文档，对于 <code>flutter</code> 开发提供 <code>flutter pub search</code>，方便搜寻pub包<br>等</li><li>支持 <code>mac</code> , <code>windows</code> , <code>linux</code> 平台下载</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_uTools.png" alt="" loading="lazy"></p><blockquote><p>快速启动</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_uTools2.png" alt="" loading="lazy"></p><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a><a href="https://www.postman.com/" target="_blank" rel="noopener">Postman</a></h3><blockquote><p><code>Postman</code> 是一款功能强大的网页调试与发送网页HTTP请求的工具</p><ul><li>方便开发测试接口数据，它能够发送任何类型的HTTP 请求 (GET, HEAD, POST, PUT)，同时能保留历史请求数据</li><li>支持 <code>mac</code>,<code>windows</code>,<code>linux</code> 平台下载 以及Google浏览器插件安装</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Postman.png" alt="" loading="lazy"></p><h3 id="MacDown"><a href="#MacDown" class="headerlink" title="MacDown"></a><a href="https://macdown.uranusjr.com/" target="_blank" rel="noopener">MacDown</a></h3><blockquote><ul><li>MacDown 是一款 Mac 下的开源 Markdown 编辑器。<a href="https://github.com/MacDownApp/macdown" target="_blank" rel="noopener">开源地址</a></li></ul></blockquote><blockquote><p>功能部分：</p><ul><li>高度可定制的 Markdown 渲染</li><li>支持代码块的语法着色</li><li>智能自动补全</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_MacDown.png" alt="" loading="lazy"></p><h3 id="typora"><a href="#typora" class="headerlink" title="typora"></a><a href="https://www.typora.io/" target="_blank" rel="noopener">typora</a></h3><blockquote><ul><li><code>Typora</code> 也是一款支持实时预览的 Markdown 文本编辑器，是完全免费的。</li><li>支持 <code>mac</code>,<code>windows</code>,<code>linux</code> 平台下载</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_typora.png" alt="" loading="lazy"></p><h2 id="推荐的网页在线工具"><a href="#推荐的网页在线工具" class="headerlink" title="推荐的网页在线工具"></a>推荐的网页在线工具</h2><h3 id="tinypng"><a href="#tinypng" class="headerlink" title="tinypng"></a><a href="https://tinypng.com/" target="_blank" rel="noopener">tinypng</a></h3><blockquote><p>在线图片压缩，支持 png,jpg</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_tinypng.png" alt="" loading="lazy"></p><h3 id="processon"><a href="#processon" class="headerlink" title="processon"></a><a href="https://www.processon.com/" target="_blank" rel="noopener">processon</a></h3><blockquote><p>免费在线作图、实时协作<br>它可以在线画流程图、思维导图、UI 原型图、UML、网络拓扑图、组织结构图等等，<br>您无需担心下载和更新的问题，不管 Mac 还是 Windows ，一个浏览器就可以随时随地的发挥创意，规划工作</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_processon.png" alt="" loading="lazy"></p><h2 id="iOS-开发工具集"><a href="#iOS-开发工具集" class="headerlink" title="iOS 开发工具集"></a>iOS 开发工具集</h2><h3 id="JSONConverter"><a href="#JSONConverter" class="headerlink" title="JSONConverter"></a><a href="https://github.com/iosyaowei/JSONConverter" target="_blank" rel="noopener">JSONConverter</a></h3><blockquote><ul><li><code>JSONConverter</code> 是MAC上iOS开发的辅助小工具，可以快速的把 json 数据转换生成对应的模型类属性，</li><li>目前支持<code>Objective-C</code>、<code>Swift</code>、<code>Flutter</code>以及目前流行的第三方库: <code>SwiftyJSON</code>、<code>HandyJSON</code>，<code>ObjectMapper</code>,可以灵活选择构建 <code>class/struct</code> ，并支持配置类名前缀等,省去手敲模型的麻烦，借此提高我们的开发效率。</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_JSONConverter.png" alt="" loading="lazy"></p><h3 id="App-Icon-Gear"><a href="#App-Icon-Gear" class="headerlink" title="App Icon Gear"></a><a href="https://apps.apple.com/cn/app/app-icon-gear/id989646576?l=en&mt=12" target="_blank" rel="noopener">App Icon Gear</a></h3><blockquote><p><code>App Icon Gear</code> 图标切割神器，只需一张1024pt图片，非常方便我们一键导出所有尺寸的icon图</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_AppIconGear.png" alt="" loading="lazy"></p><h3 id="Swiftify"><a href="#Swiftify" class="headerlink" title="Swiftify"></a><a href="https://swiftify.com/converter/home/" target="_blank" rel="noopener">Swiftify</a></h3><blockquote><ul><li><code>swiftify</code>插件。支持在线转换，或者添加插件到Xcode中,方便快速将Object-C代码转换为Swift</li><li><a href="https://itunes.apple.com/cn/app/swiftify-objective-c-converter-for-xcode/id1183412116?mt=12" target="_blank" rel="noopener">插件安装AppStore下载地址</a></li><li><a href="https://swiftify.com/converter/code/" target="_blank" rel="noopener">在线转换地址</a></li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Swiftify.png" alt="" loading="lazy"></p><h3 id="quicktype"><a href="#quicktype" class="headerlink" title="quicktype"></a><a href="https://app.quicktype.io/" target="_blank" rel="noopener">quicktype</a></h3><blockquote><ul><li>快速将json转化为Swift的模型对象</li><li>基于Codable协议快速的数模序列化</li><li>它不仅支持Swift,还支持其他语言比如Kotlin,Java,C#,Ruby,Object-c,Python</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_quicktype.png" alt="" loading="lazy"></p><h3 id="Lookin"><a href="#Lookin" class="headerlink" title="Lookin"></a><a href="https://lookin.work/" target="_blank" rel="noopener">Lookin</a></h3><blockquote><p><code>Lookin</code> 可以查看与修改 iOS App 里的 UI 对象，类似于 Xcode 自带的 UI Inspector 工具，或另一款叫做 Reveal 的软件。但借助于“控制台”和“方法监听”功能，Lookin 还可以进行 UI 之外的调试。<br>此外，虽然 Lookin 主体是一款 macOS 程序，它亦可嵌入你的 iOS App 而单独运行在 iPhone 或 iPad 上。最后，Lookin 完全免费。</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Lookin.png" alt="" loading="lazy"></p><h3 id="Echo"><a href="#Echo" class="headerlink" title="Echo"></a><a href="https://github.com/didi/echo" target="_blank" rel="noopener">Echo</a></h3><blockquote><p><code>Echo</code>是一款客户端的桌面端调试工具，中文意思回声，寓意着Mac端和手机端之间就像回声一样相互联动。</p><ul><li>简单易用：将 Echo 和 App 连接到同一个局域网即可，无须额外配置。</li><li>功能齐全：目前已拥有网络请求、视图层级查看修改等10几个功能，覆盖了客户端研发的大部分场景。</li></ul></blockquote><blockquote><p>功能部分：</p><ul><li>高扩展性：插件和模块机制可以方便我们快速添加新功能。</li><li>基础功能：网络请求、NSUserDefaults 查看修改、日志查看、Crash 查看、GPS 模拟、通知查看</li><li>UI视图：视图层级查看修改、视图边框查看<br>性能检测：内存泄漏、卡顿检测</li><li>业务功能：基于插件能力可快速扩展你自己的业务插件能力</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Echo.png" alt="" loading="lazy"></p><h3 id="SQLProSQLite"><a href="#SQLProSQLite" class="headerlink" title="SQLProSQLite"></a><a href="http://www.sqlitepro.com/" target="_blank" rel="noopener">SQLProSQLite</a></h3><blockquote><ul><li><code>SQLProSQLite</code>是一款优秀的数据库管理工具，不过要<code>付费</code> </li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_SQLProSQLite.png" alt="" loading="lazy"></p><h3 id="BuildTimeAnalyzer"><a href="#BuildTimeAnalyzer" class="headerlink" title="BuildTimeAnalyzer"></a><a href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode" target="_blank" rel="noopener">BuildTimeAnalyzer</a></h3><blockquote><ul><li>项目中的 Swift 代码越写越多，发觉编译速度开始变慢。BuildTimeAnalyzer 工具可以检测项目中 Swift 的编译速度。</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_BuildTimeAnalyzer.png" alt="" loading="lazy"></p><h3 id="Perfdog"><a href="#Perfdog" class="headerlink" title="Perfdog"></a><a href="https://perfdog.qq.com/" target="_blank" rel="noopener">Perfdog</a></h3><blockquote><ul><li>移动全平台 iOS/Android 性能测试、分析工具平台。快速定位分析性能问题，提升 APP 应用及游戏性能和品质。手机无需 ROOT/ 越狱，手机硬件、游戏及应用 APP 也无需做任何修改，极简化即插即用。</li><li>支持 <code>mac</code> , <code>windows</code>,平台下载</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Perfdog.png" alt="" loading="lazy"></p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a><a href="https://www.jenkins.io/" target="_blank" rel="noopener">Jenkins</a></h3><blockquote><ul><li><code>Jenkins</code>是开源 CI&amp;CD 软件领导者，提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。</li></ul></blockquote><blockquote><p>功能部分</p><ul><li>持续集成和持续交付</li><li>简易安装，配置简单</li><li>支持插件</li><li>扩展，分布式</li></ul></blockquote><blockquote><p>目前我们部门 <code>Jenkins</code> 平台已集成，自动化构建 <code>测试包</code> ，<code>AppStore包</code>，<code>图片压缩</code>，<code>OCLint</code> <code>SwiftLint</code> 语法检测，<code>组件自动构建</code>等，未来可期…</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Jenskin.png" alt="" loading="lazy"></p><h2 id="日常用的工具集"><a href="#日常用的工具集" class="headerlink" title="日常用的工具集"></a>日常用的工具集</h2><blockquote><p>我的工具集全家桶</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_all.png" alt="" loading="lazy"></p><h2 id="网友推荐篇"><a href="#网友推荐篇" class="headerlink" title="网友推荐篇"></a>网友推荐篇</h2><h3 id="KnuffApp"><a href="#KnuffApp" class="headerlink" title="KnuffApp"></a><a href="https://github.com/KnuffApp/Knuff" target="_blank" rel="noopener">KnuffApp</a></h3><blockquote><p>iOS 苹果推送测试工具, Mac OS 下的 apns 测试工具 ，类似的还有 <a href="https://github.com/shaojiankui/SmartPush" target="_blank" rel="noopener">SmartPush</a></p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_KnuffApp.jpg" alt="" loading="lazy"></p><h3 id="Bagel"><a href="#Bagel" class="headerlink" title="Bagel"></a><a href="https://github.com/yagiz/Bagel" target="_blank" rel="noopener">Bagel</a></h3><blockquote><p><code>Bagel</code> 是一个小型的本地 iOS 网络调试器。它不是一个代理调试器，所以你不必纠结于证书、代理设置等。只要你的 iOS 设备和你的 Mac 在同一个网络中，你就可以查看由设备或模拟器分开的应用程序的网络流量。</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Bagel.png" alt="" loading="lazy"></p><h3 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a><a href="https://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">Go2Shell</a></h3><blockquote><p><code>Go2Shell</code> 是一个可从Finder窗口在所需位置打开终端的工具。</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Go2Shell.png" alt="" loading="lazy"></p><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a></h3><blockquote><p><code>Alfred</code> 免费用户只能只能使用基本搜索和快速启动应用功能，若要使用Workflows，则需要购买Powerpack。</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Alfred.jpg" alt="" loading="lazy"></p><h3 id="XSimulatorMngr"><a href="#XSimulatorMngr" class="headerlink" title="XSimulatorMngr"></a><a href="https://github.com/xndrs/XSimulatorMngr" target="_blank" rel="noopener">XSimulatorMngr</a></h3><blockquote><p><code>XSimulatorMngr</code> 快速查看iOS模拟器文件的工具,类似 <a href="https://simpholders.com/" target="_blank" rel="noopener">SimPholders</a></p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_XSimulatorMngr.png" alt="" loading="lazy"></p><h3 id="Prepo"><a href="#Prepo" class="headerlink" title="Prepo"></a><a href="https://apps.apple.com/tw/app/prepo/id476533227?mt=12" target="_blank" rel="noopener">Prepo</a></h3><blockquote><p>Prepo 类似 <code>App Icon Gear</code> 一样只需1024pt图，导出需要icon</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Prepo.png" alt="" loading="lazy"></p><blockquote><p>…期待网友推荐待</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><p>重提下，此篇我们常用的各种<code>神兵利器</code>。如果有朋友能推荐更好的欢迎补充，分享给我,谢谢！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作为&lt;code&gt;iOS&lt;/code&gt;开发老司机们，我们肯定有各种各样的开发利器，以追求着&lt;code&gt;最高效率&lt;/c
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ios13苹果对UIWebView不再支持</title>
    <link href="https://zhengzeqin.netlify.app/2020/05/13/ios13%E8%8B%B9%E6%9E%9C%E5%AF%B9UIWebView%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81/"/>
    <id>https://zhengzeqin.netlify.app/2020/05/13/ios13%E8%8B%B9%E6%9E%9C%E5%AF%B9UIWebView%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81/</id>
    <published>2020-05-13T19:03:04.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UIWebView-将被禁止提交审核"><a href="#UIWebView-将被禁止提交审核" class="headerlink" title="UIWebView 将被禁止提交审核"></a>UIWebView 将被禁止提交审核</h2><h3 id="在-iOS-13-推出后，如果开发者将包含-UIWebViewapi-的应用更新上传到-App-Store-审核后，其将会收到包含-ITMS-90809信息的回复邮件，提示你在下一次提交时将应用中-UIWebView的-api-移除。"><a href="#在-iOS-13-推出后，如果开发者将包含-UIWebViewapi-的应用更新上传到-App-Store-审核后，其将会收到包含-ITMS-90809信息的回复邮件，提示你在下一次提交时将应用中-UIWebView的-api-移除。" class="headerlink" title="在 iOS 13 推出后，如果开发者将包含 UIWebViewapi 的应用更新上传到 App Store 审核后，其将会收到包含 ITMS-90809信息的回复邮件，提示你在下一次提交时将应用中 UIWebView的 api 移除。"></a>在 iOS 13 推出后，如果开发者将包含 UIWebViewapi 的应用更新上传到 App Store 审核后，其将会收到包含 ITMS-90809信息的回复邮件，提示你在下一次提交时将应用中 UIWebView的 api 移除。</h3><blockquote><p>Dear Developer,<br>We identified one or more issues with a recent delivery for your app, “xxxxxxx. Your delivery was successful, but you may wish to correct the following issues in your next delivery:<br>ITMS-90809: Deprecated API Usage - Apple will no longer accept submissions of new apps that use UIWebView as of April 30, 2020 and app updates that use UIWebView as of December 2020. Instead, use WKWebView for improved security and reliability. Learn more (<a href="https://developer.apple.com/documentation/uikit/uiwebview" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uiwebview</a>).<br>After you’ve corrected the issues, you can upload a new binary to App Store Connect.<br>Best regards,<br>The App Store Team</p></blockquote><h3 id="项目用了一些第三库，比如WebViewJavascriptBridge-和-AFNetworking"><a href="#项目用了一些第三库，比如WebViewJavascriptBridge-和-AFNetworking" class="headerlink" title="项目用了一些第三库，比如WebViewJavascriptBridge 和 AFNetworking"></a>项目用了一些第三库，比如WebViewJavascriptBridge 和 AFNetworking</h3><ul><li><p>目前AFNetworking 已出4.0版本已移除UIWebView相关文件</p></li><li><p>假设我们不想手动删除文件或者更新最新库，可以通过Podfile配置移除涉及UIWebView相关的文件</p><blockquote><p>参考如下</p></blockquote><pre><code>post_install do |installer|  dir_web = File.join(installer.sandbox.pod_dir(&#39;WebViewJavascriptBridge&#39;), &#39;WebViewJavascriptBridge&#39;)  Dir.foreach(dir_web) {|x|    real_path = File.join(dir_web, x)    if (!File.directory?(real_path) &amp;&amp; File.exists?(real_path))      if(x == &#39;WebViewJavascriptBridge.h&#39; || x == &#39;WebViewJavascriptBridge.m&#39;)        File.delete(real_path)      end    end  }  dir_web = File.join(installer.sandbox.pod_dir(&#39;AFNetworking&#39;), &#39;UIKit+AFNetworking&#39;)  Dir.foreach(dir_web) {|x|    real_path = File.join(dir_web, x)    if (!File.directory?(real_path) &amp;&amp; File.exists?(real_path))      if(x == &#39;UIWebView+AFNetworking.h&#39; || x == &#39;UIWebView+AFNetworking.m&#39; || x == &#39;UIKit+AFNetworking.h&#39;)        File.delete(real_path)      end    end  }</code></pre></li></ul><p>end</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UIWebView-将被禁止提交审核&quot;&gt;&lt;a href=&quot;#UIWebView-将被禁止提交审核&quot; class=&quot;headerlink&quot; title=&quot;UIWebView 将被禁止提交审核&quot;&gt;&lt;/a&gt;UIWebView 将被禁止提交审核&lt;/h2&gt;&lt;h3 id=&quot;在
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins-fastlane自动构建</title>
    <link href="https://zhengzeqin.netlify.app/2020/04/28/Jenkins-fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    <id>https://zhengzeqin.netlify.app/2020/04/28/Jenkins-fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/</id>
    <published>2020-04-28T19:03:02.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jenkins自动构建-去年基于Jenkins平台搭建的自动构建流程图"><a href="#Jenkins自动构建-去年基于Jenkins平台搭建的自动构建流程图" class="headerlink" title="Jenkins自动构建 去年基于Jenkins平台搭建的自动构建流程图"></a>Jenkins自动构建 去年基于Jenkins平台搭建的自动构建流程图</h1><p><img src="/images/2020/Jenkins+fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/1.png" alt="" loading="lazy"></p><p><img src="/images/2020/Jenkins+fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/2.png" alt="" loading="lazy"></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>Jenkins 作用及特点</li><li>怎么搭建Jenkins平台</li><li>Jenkins+fastlane的持续集成</li><li>怎么使用Jenkins触发自动打包构建</li><li>Jenkins构建遇到问题整理及解决</li><li>目前功能与未来的拓展</li></ul><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>Jenkins是开源CI&amp;CD软件领导者， 提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>持续集成和持续交付</li><li>简易安装，配置简单</li><li>支持插件</li><li>扩展，分布式<h2 id="怎么搭建Jenkins平台"><a href="#怎么搭建Jenkins平台" class="headerlink" title="怎么搭建Jenkins平台"></a>怎么搭建Jenkins平台</h2></li><li>安装Java环境<ul><li>安装Java环境，目前jenkins只支持jdk8 </li></ul></li><li>安装 Jenkins<ul><li>先确保已安装Homebrew</li><li>命令安装 brew install jenkins</li><li>设置开机自启动</li></ul></li><li>启动 Jenkins <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li><li>安装插件<ul><li>Keychains and Provisioning Profiles - Management（管理本地的keychain和iOS证书的插件）</li><li>Xcode integration （用于xcode构建）</li></ul></li></ul><h2 id="Jenkins-fastlane持续集成"><a href="#Jenkins-fastlane持续集成" class="headerlink" title="Jenkins+fastlane持续集成"></a>Jenkins+fastlane持续集成</h2><ul><li>Fastlane是一整套的客户端CICD工具集合。Fastlane可以非常快速简单的搭建一个自动化发布服务，并且支持Android，iOS，MacOS。</li><li>Fastlane命令执行的底层并不是自己实现的，而是调用其他的插件或者工具执行的。比如说打包，Fastlane中的gym工具只是xcodebuild工具的一个封装，调用的其实还是xcodebuild中的打包命令。</li><li>Fastlane本身没有一套特殊语法，使用的Ruby语言。</li><li>Fastlane的插件工具叫做action，每一个action都对应一个具体的功能</li></ul><h2 id="目前功能与未来的拓展"><a href="#目前功能与未来的拓展" class="headerlink" title="目前功能与未来的拓展"></a>目前功能与未来的拓展</h2><ul><li>目前集成功能：<ul><li>测试包部署</li><li>线上包部署</li><li>静态图片压缩</li><li>OCLint语法检测</li></ul></li><li>未来优化点<ul><li>推送代码整合一套构建流程功能</li><li>简繁体转换集成</li><li>SwiftLint语法检测集成</li><li>…</li></ul></li></ul><p><img src="/images/2020/Jenkins+fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/3.png" alt="" loading="lazy"></p><h3 id="具体配置待补充-未完待续"><a href="#具体配置待补充-未完待续" class="headerlink" title="具体配置待补充 , 未完待续.."></a>具体配置待补充 , 未完待续..</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jenkins自动构建-去年基于Jenkins平台搭建的自动构建流程图&quot;&gt;&lt;a href=&quot;#Jenkins自动构建-去年基于Jenkins平台搭建的自动构建流程图&quot; class=&quot;headerlink&quot; title=&quot;Jenkins自动构建 去年基于Jenkin
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>MVVM架构优势及应用场景</title>
    <link href="https://zhengzeqin.netlify.app/2019/08/23/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://zhengzeqin.netlify.app/2019/08/23/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2019-08-23T19:03:02.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxSwift应用"><a href="#RxSwift应用" class="headerlink" title="RxSwift应用"></a>RxSwift应用</h1><h2 id="响应式编程-amp-amp-函数式编程"><a href="#响应式编程-amp-amp-函数式编程" class="headerlink" title="响应式编程 &amp;&amp; 函数式编程"></a>响应式编程 &amp;&amp; 函数式编程</h2><h3 id="什么是响应式编程？"><a href="#什么是响应式编程？" class="headerlink" title="什么是响应式编程？"></a>什么是响应式编程？</h3><blockquote><p>响应式编程，响应式编程是一种面向数据流和变化传播的编程方式式，简单理解就是异步的数据流的开发。</p></blockquote><h3 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h3><blockquote><p>特点是将函数作为一等公民，当作参数和返回值使用。典型的如OC和Swift 中的 map函数、filter函数、reduce函数等。每个函数的处理结果给到下一个函数，最后的结果由自身函数调出。</p></blockquote><hr><ul><li><a href="https://www.v2ex.com/amp/t/367308" target="_blank" rel="noopener">从入门到放弃</a><br><img src="/images/2019/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/1.png" alt="" loading="lazy"><h2 id="为什么要使用-RxSwift-？"><a href="#为什么要使用-RxSwift-？" class="headerlink" title="为什么要使用 RxSwift ？"></a>为什么要使用 RxSwift ？</h2></li></ul><h3 id="我们先看一下-RxSwift-能够帮助我们做些什么："><a href="#我们先看一下-RxSwift-能够帮助我们做些什么：" class="headerlink" title="我们先看一下 RxSwift 能够帮助我们做些什么："></a>我们先看一下 RxSwift 能够帮助我们做些什么：</h3><h4 id="Target-Action"><a href="#Target-Action" class="headerlink" title="Target Action"></a>Target Action</h4><p>传统实现方法：</p><pre><code class="swift">button.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside)func buttonTapped() {    print(&quot;button Tapped&quot;)}</code></pre><p>通过 Rx 来实现：</p><pre><code class="swift">button.rx.tap    .subscribe(onNext: {        print(&quot;button Tapped&quot;)    })    .disposed(by: disposeBag)</code></pre><p>你不需要使用 Target Action，这样使得代码逻辑清晰可见。</p><hr><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>传统实现方法：</p><pre><code class="swift">class ViewController: UIViewController {    override func viewDidLoad() {        super.viewDidLoad()        scrollView.delegate = self    }}extension ViewController: UIScrollViewDelegate {    func scrollViewDidScroll(_ scrollView: UIScrollView) {        print(&quot;contentOffset: \(scrollView.contentOffset)&quot;)    }}</code></pre><p>通过 Rx 来实现：</p><pre><code class="swift">class ViewController: UIViewController {    override func viewDidLoad() {        super.viewDidLoad()        scrollView.rx.contentOffset            .subscribe(onNext: { contentOffset in                print(&quot;contentOffset: \(contentOffset)&quot;)            })            .disposed(by: disposeBag)    }}</code></pre><p>你不需要书写代理的配置代码，就能获得想要的结果。</p><hr><h3 id="闭包回调"><a href="#闭包回调" class="headerlink" title="闭包回调"></a>闭包回调</h3><p>传统实现方法：</p><pre><code class="swift">URLSession.shared.dataTask(with: URLRequest(url: url)) {    (data, response, error) in    guard error == nil else {        print(&quot;Data Task Error: \(error!)&quot;)        return    }    guard let data = data else {        print(&quot;Data Task Error: unknown&quot;)        return    }    print(&quot;Data Task Success with count: \(data.count)&quot;)}.resume()</code></pre><p>通过 Rx 来实现：</p><pre><code class="swift">URLSession.shared.rx.data(request: URLRequest(url: url))    .subscribe(onNext: { data in        print(&quot;Data Task Success with count: \(data.count)&quot;)    }, onError: { error in        print(&quot;Data Task Error: \(error)&quot;)    })    .disposed(by: disposeBag)</code></pre><p>回调也变得十分简单</p><hr><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>传统实现方法：</p><pre><code class="swift">override func viewDidLoad() {    super.viewDidLoad()    NotificationCenter.default.addObserver(self, selector: #selector(updateNotificationStatus),                                                      name: UIApplication.willEnterForegroundNotification,                                                   object: nil)}deinit {    NotificationCenter.default.removeObserver(self)}// MARK: - Notification@objc func updateNotificationStatus(){    print(&quot;Application Will Enter Foreground&quot;)}</code></pre><p>通过 Rx 来实现：</p><pre><code class="swift">override func viewDidLoad() {    super.viewDidLoad()    NotificationCenter.default.rx.notification(UIApplication.willEnterForegroundNotification)    .subscribe(onNext: { (notification) in        print(&quot;Application Will Enter Foreground&quot;)    }).disposed(by: disposeBag)}</code></pre><p>你不需要去管理观察者的生命周期，这样你就有更多精力去关注业务逻辑。</p><hr><h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><p>传统实现方法：</p><pre><code class="swift">private var observerContext = 0override func viewDidLoad() {    super.viewDidLoad()    user.addObserver(self, forKeyPath: #keyPath(User.name), options: [.new, .initial], context: &amp;observerContext)}override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {    if context == &amp;observerContext {        let newValue = change?[.newKey] as? String        print(&quot;do something with newValue&quot;)    } else {        super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)    }}deinit {    user.removeObserver(self, forKeyPath: #keyPath(User.name))}</code></pre><p>通过 Rx 来实现：</p><pre><code class="swift">override func viewDidLoad() {    super.viewDidLoad()    user.rx.observe(String.self, #keyPath(User.name))        .subscribe(onNext: { newValue in            print(&quot;do something with newValue&quot;)        })        .disposed(by: disposeBag)}</code></pre><p>这样实现 KVO 的代码更清晰，更简洁并且更准确。</p><hr><h4 id="多个任务之间有依赖关系"><a href="#多个任务之间有依赖关系" class="headerlink" title="多个任务之间有依赖关系"></a>多个任务之间有依赖关系</h4><p>例如，先通过用户名密码取得 Token 然后通过 Token 取得用户信息，</p><p>传统实现方法：</p><pre><code class="swift">/// 用回调的方式封装接口enum API {    /// 通过用户名密码取得一个 token    static func token(username: String, password: String,        success: (String) -&gt; Void,        failure: (Error) -&gt; Void) { ... }    /// 通过 token 取得用户信息    static func userinfo(token: String,        success: (UserInfo) -&gt; Void,        failure: (Error) -&gt; Void) { ... }}</code></pre><pre><code class="swift">/// 通过用户名和密码获取用户信息API.token(username: &quot;beeth0ven&quot;, password: &quot;987654321&quot;,    success: { token in        API.userInfo(token: token,            success: { userInfo in                print(&quot;获取用户信息成功: \(userInfo)&quot;)            },            failure: { error in                print(&quot;获取用户信息失败: \(error)&quot;)        })    },    failure: { error in        print(&quot;获取用户信息失败: \(error)&quot;)})</code></pre><p>通过 Rx 来实现：</p><pre><code class="swift">/// 用 Rx 封装接口enum API {    /// 通过用户名密码取得一个 token    static func token(username: String, password: String) -&gt; Observable&lt;String&gt; { ... }    /// 通过 token 取得用户信息    static func userInfo(token: String) -&gt; Observable&lt;UserInfo&gt; { ... }}</code></pre><pre><code class="swift">/// 通过用户名和密码获取用户信息API.token(username: &quot;beeth0ven&quot;, password: &quot;987654321&quot;)    .flatMapLatest(API.userInfo)    .subscribe(onNext: { userInfo in        print(&quot;获取用户信息成功: \(userInfo)&quot;)    }, onError: { error in        print(&quot;获取用户信息失败: \(error)&quot;)    })    .disposed(by: disposeBag)</code></pre><p>这样你无需嵌套太多层，从而使得代码易读，易维护。</p><hr><h4 id="等待多个并发任务完成后处理结果"><a href="#等待多个并发任务完成后处理结果" class="headerlink" title="等待多个并发任务完成后处理结果"></a>等待多个并发任务完成后处理结果</h4><p>例如，需要将两个网络请求合并成一个，</p><p>通过 Rx 来实现：</p><pre><code class="swift">/// 用 Rx 封装接口enum API {    /// 取得老师的详细信息    static func teacher(teacherId: Int) -&gt; Observable&lt;Teacher&gt; { ... }    /// 取得老师的评论    static func teacherComments(teacherId: Int) -&gt; Observable&lt;[Comment]&gt; { ... }}</code></pre><pre><code class="swift">/// 同时取得老师信息和老师评论Observable.zip(      API.teacher(teacherId: teacherId),      API.teacherComments(teacherId: teacherId)    ).subscribe(onNext: { (teacher, comments) in        print(&quot;获取老师信息成功: \(teacher)&quot;)        print(&quot;获取老师评论成功: \(comments.count) 条&quot;)    }, onError: { error in        print(&quot;获取老师信息或评论失败: \(error)&quot;)    })    .disposed(by: disposeBag)</code></pre><p>这样你可用寥寥几行代码来完成相当复杂的异步操作。</p><hr><h3 id="RxSwift-的单向数据流"><a href="#RxSwift-的单向数据流" class="headerlink" title="RxSwift 的单向数据流"></a>RxSwift 的单向数据流</h3><p>RxSwift 可以在 UniDirectional Data Flow 的各个阶段都发挥作用，从而让 Data 的处理和流动更加简洁和清晰。<br><img src="/images/2019/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/2.png" alt="" loading="lazy"></p><ul><li>通过对 RxCocoa 的各种回调进行统一处理，方便了”交互”「Interact」的处理。</li><li>通过对 Observable 的 transform 和 composite，方便了 Action 的生成（比如使用 throttle 来压缩 Action）。</li><li>通过对网络请求以及其他异步数据的获取进行 Observable 封装，方便了异步数据的处理。</li><li>通过 RxCocoa 的 binding，方便了数据的渲染。</li></ul><h3 id="RxSwift优势"><a href="#RxSwift优势" class="headerlink" title="RxSwift优势"></a>RxSwift优势</h3><ul><li>组合 - Rx对不同的信号进行组合</li><li>复用 - 因为它是可组合的</li><li>清晰 - 因为声明都是不可变的，改变的只有数据</li><li>易用 - 因为它抽象的了异步编程，使我们统一了代码风格</li><li>内存回收 - 简单内存管理</li><li>稳定 - 因为 Rx 是完全通过单元测试的</li></ul><h2 id="RxSwift-与-MVVM的邂逅"><a href="#RxSwift-与-MVVM的邂逅" class="headerlink" title="RxSwift 与 MVVM的邂逅"></a>RxSwift 与 MVVM的邂逅</h2><blockquote><p>MVVM 是 Model-View-ViewModel 的缩写。</p></blockquote><ul><li>MVVM 增加了 ViewModel 层。我们可以将原来 Controller 中的业务逻辑抽取出来放到 ViewModel 中，从而大大减轻了 ViewController 的负担。</li><li>同时在 MVVM 中，ViewController 只担任 View 的角色（ViewController 与 View 现在共同作为 View 层），负责 View 的显示和更新，其他业务逻辑不再需要 ViewController 来管了。</li></ul><blockquote><p>同样使用 MVVM 架构时，Model 与 View|ViewControllter 之间是不允许直接通信的，而是由 ViewModel 层进行协调</p></blockquote><p><img src="/images/2019/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/3.png" alt="" loading="lazy"></p><h4 id="基于RxSwift对网络工具封装-TWSwiftHttpTool"><a href="#基于RxSwift对网络工具封装-TWSwiftHttpTool" class="headerlink" title="基于RxSwift对网络工具封装 TWSwiftHttpTool"></a>基于RxSwift对网络工具封装 TWSwiftHttpTool</h4><pre><code>// 声明一个枚举，包含成功和失败的情况enum TWSwiftHttpResult {    case success(Any)  //成功    case failure(String) //失败    case noNet() //无网络}// 使用RxSwift进行扩展extension Reactive where Base: TWSwiftHttpTool {    /// 基于YYCache 缓存的RXSwift 请求方式    static func request(type: TWRequestType,                        url: String,                        parameters: [AnyHashable: Any]?,                        flag: Bool = true,                        isCache: Bool = false,                        cacheKey: String? = nil,                        cacheBlock: (CacheBlock)? = nil) -&gt; Observable&lt;Any&gt; {        return Observable.create { observer in            let task = TWSwiftHttpTool.request(type: type, url: url, flag: flag, parameters: parameters, isCache: isCache, cacheKey: cacheKey, cacheBlock: cacheBlock, complete: { (result) in                dealComplete(result: result, observer: observer)            })            return Disposables.create(with: task.cancel)        }    }    // MARK: - Private Common Method    private static func dealComplete(result:TWSwiftHttpResult,observer:AnyObserver&lt;Any&gt;) {        switch result {        case .success(let response):            observer.onNext(response)            observer.onCompleted()        case .failure(let reason)://            observer.onNext([TWSwiftErrorMsg:reason])            observer.onError(RxNetworkError.general(reason))        case .noNet://            observer.onNext([TWSwiftErrorMsg:TWSwiftNoNetMsg])            observer.onError(RxNetworkError.noNet)        }    }}</code></pre><h4 id="viewModel-定义"><a href="#viewModel-定义" class="headerlink" title="viewModel 定义"></a>viewModel 定义</h4><pre><code>//订阅输入输出协议protocol TWSwiftViewModelProtocol {    associatedtype TWSwiftInput    associatedtype TWSwiftOutput    func transform(input: TWSwiftInput) -&gt; TWSwiftOutput}//viewModel实现TWSwiftViewModelProtocol的协议extension NewHouseWeekViewModel:TWSwiftViewModelProtocol{    typealias TWSwiftInput = Input    typealias TWSwiftOutput = Output    // MARK: - Override Method    struct Input {        //即是订阅又是被订阅        let requestId = PublishSubject&lt;String&gt;()    }    struct Output {        //输出数据源        let sections: Driver&lt;[NewHouseWeekSectionModel]&gt;        //成功输出        let successSubject = PublishSubject&lt;String&gt;()        //错误输出        let errorSubject = PublishSubject&lt;String&gt;()        init(sections: Driver&lt;[NewHouseWeekSectionModel]&gt;) {            self.sections = sections        }    }    func transform(input: NewHouseWeekViewModel.Input) -&gt; NewHouseWeekViewModel.Output {        ```    }}</code></pre><h4 id="viewController通过viewModel实现model与view绑定"><a href="#viewController通过viewModel实现model与view绑定" class="headerlink" title="viewController通过viewModel实现model与view绑定"></a>viewController通过viewModel实现model与view绑定</h4><pre><code>/// viewModel绑定    fileprivate func bindViewModel() {        let vmInput = NewHouseWeekViewModel.Input() ///输入        let vmOutput = viewModel.transform(input: vmInput) ///输出        ///数据源绑定到tableview中        vmOutput.sections.asDriver().drive(tableView.rx.items(dataSource: dataSource)).disposed(by: TWSwiftDisposeBag)        ///错误订阅        vmOutput.errorSubject.subscribe(onNext:{[weak self] (errorMsg) in            self?.hideHud(in: self?.tableView, hint: errorMsg)            self?.setEmptyDic()        }).disposed(by: TWSwiftDisposeBag)        ///成功订阅        vmOutput.successSubject.subscribe(onNext: nil, onError: nil, onCompleted: {[weak self] in            self?.hideHUD()            self?.setEmptyDic()        }, onDisposed: nil).disposed(by: TWSwiftDisposeBag)        let regionId = TWSwiftGuardNullString(GlobalObject.share()?.regionId)        ///发起数据请求        vmInput.requestId.onNext(regionId)        self.showActivityIndicatorSuperView(tableView)    }</code></pre><h3 id="RxSwift的看法"><a href="#RxSwift的看法" class="headerlink" title="RxSwift的看法"></a>RxSwift的看法</h3><blockquote><p>理解响应链的编程思路<br>RxSwift给我们带来最大影响的Reactive思想，OOP告诉我们，在编写应用程序的时候，要考虑的是对象有什么，对象做什么，对象与对象之间的联系，而Reactive思想将对象所做的都看成是数据流，我们关注的是事件本身的影响。</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.jianshu.com/p/f61a5a988590" target="_blank" rel="noopener">RxSwift 使用详解系列</a></li><li><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/" target="_blank" rel="noopener">RxSwift中文文档</a></li><li><a href="https://limboy.me/tech/2016/12/11/time-to-learn-rxswift.html" target="_blank" rel="noopener">是时候学习 RxSwift 了</a></li><li><a href="http://note.youdao.com/noteshare?id=ad1212ce231507cb934fd08dcc673d30" target="_blank" rel="noopener">RxSwift的整理</a></li><li><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift github</a></li><li><a href="http://bookmobile.debug.591.com.tw/" target="_blank" rel="noopener">项目框架</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RxSwift应用&quot;&gt;&lt;a href=&quot;#RxSwift应用&quot; class=&quot;headerlink&quot; title=&quot;RxSwift应用&quot;&gt;&lt;/a&gt;RxSwift应用&lt;/h1&gt;&lt;h2 id=&quot;响应式编程-amp-amp-函数式编程&quot;&gt;&lt;a href=&quot;#响应式编程-
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>基于Jenkins-Gitlab-蒲公英-附上shell脚本</title>
    <link href="https://zhengzeqin.netlify.app/2019/04/11/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/"/>
    <id>https://zhengzeqin.netlify.app/2019/04/11/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/</id>
    <published>2019-04-11T19:03:00.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jenkins-持续集成"><a href="#Jenkins-持续集成" class="headerlink" title="Jenkins 持续集成"></a>Jenkins 持续集成</h1><h2 id="自动化打包分发"><a href="#自动化打包分发" class="headerlink" title="自动化打包分发"></a>自动化打包分发</h2><blockquote><p>基于Jenkins + Gitlab + 蒲公英</p></blockquote><h3 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h3><h4 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h4><ol><li>安装Java环境，目前jenkins只支持jdk8 <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">下载地址</a><blockquote><ol><li>安装完使用命令 java -version检查当前版本</li><li>java选择如图</li></ol></blockquote></li></ol><p><img src="/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/1.png" alt="" loading="lazy"></p><ol start="2"><li>安装 Jenkins</li></ol><ul><li><p>先确保已安装<a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew</a> </p></li><li><p>命令安装 brew install jenkins</p></li><li><p>设置开机自启动</p><ul><li><p>创建一个链接到开机启动文件夹里</p><pre><code>ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</code></pre></li><li><p>手动启动jenkins </p><pre><code>launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code></pre></li><li><p>手动关闭jenkins</p><pre><code>launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code></pre></li></ul></li></ul><ol start="3"><li>启动 Jenkins<blockquote><p>浏览器打开连接</p></blockquote></li></ol><ul><li><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li></ul><ol start="4"><li>按照提示，找到/Users/wsh/.jenkins/secrets/initialAdminPassword 这个目录下的initialAdminPassword文件</li><li>Install suggested plugins 安装推荐插件</li><li>安装GitLab Plugin 和 Gitlab Hook Plugin</li></ol><h4 id="配置shell脚本"><a href="#配置shell脚本" class="headerlink" title="配置shell脚本"></a>配置shell脚本</h4><blockquote><p>注意 将shell脚本保存到工程目录下  保存为 zzq.sh</p></blockquote><pre><code>SECONDS=0#默认使用的语言是英文export LANG=zh_CN.UTF-8export LC_ALL=zh_CN.UTF-8#假设脚本放置在与项目相同的路径下project_dir=$(pwd)#编辑上传的文件全部放于此路径下,不影响原工程 ，保存项目目录地址upload_dir=&quot;/Users/addcn/Documents/591TestAndUpload&quot;if [ -d &quot;$upload_dir&quot; ]; then    echo &quot;编辑上传的文件输出文件目录存在,目录为:$upload_dir&quot; else     echo &quot;编辑上传的文件目录不存在&quot;     mkdir -pv $upload_dir    echo &quot;创建打包文件目录${upload_dir}成功&quot;fi#打包配置环境configuration=&quot;Release&quot;#判断是用的xcodeproj还是直接xcworkspace，xcworkspace设置为true，否则设置为falseisWorkSpace=true#项目名称scheme=`find . -name *.xcodeproj | awk -F &quot;[/.]&quot; &#39;{print $(NF-1)}&#39;`projectName=&quot;${scheme}.xcworkspace&quot;#确定工程名称，如果用了cocopods，则使用xcworkspace，但是没有该文件则使用xcodeproj进行if [ -a &quot;$project_dir/$projectName&quot; ]; then    isWorkSpace=true    projectName=&quot;${scheme}.xcworkspace&quot;else    isWorkSpace=false    projectName=&quot;${scheme}.xcodeproj&quot;fi#指定项目地址project_path=&quot;$project_dir/$projectName&quot;#确认输出日期buildDate=$(date +%Y%m%d%H%M%S)#指定输出路径output_path=&quot;$upload_dir/package$buildDate&quot;#指定输出归档文件地址archive_path=&quot;$output_path/${scheme}.xcarchive&quot;#指定输出ipa名称ipa_name=&quot;${scheme}.ipa&quot;#指定输出ipa地址ipa_path=&quot;$output_path/$ipa_name&quot;#指定xarchive文件导出授权样式 bundle idprovisioningProfileName=&quot;XC iOS: com.xxxx.xxxxxxx&quot;#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数export_method=&#39;ad-hoc&#39;###############获取版本号,bundleIDinfoPlist=&quot;$project_dir/$scheme-Info.plist&quot;bundleVersion=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $infoPlist`bundleIdentifier=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleIdentifier&quot; $infoPlist`bundleBuildVersion=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; $infoPlist`displayname=`/usr/libexec/PlistBuddy -c &quot;Print CFBundleDisplayName&quot; $infoPlist`#输出设定的变量值echo  &quot;项目名:$projectName&quot;echo &quot;===项目路径: ${project_path}===&quot;echo &quot;===打包xarchive文件路径: ${archive_path}===&quot;echo &quot;===打包ipa文件路径: ${ipa_path}===&quot;echo &quot;~~~~~~~~~~~~~~~~~~~开始编译~~~~~~~~~~~~~~~~~~~&quot;#处理没有输出打包文件目录的情况if [ -d &quot;$output_path&quot; ]; then    echo &quot;打包文件输出文件目录存在,目录为:$output_path&quot; else     echo &quot;打包文件目录不存在&quot;     mkdir -pv $output_path    echo &quot;创建打包文件目录${output_path}成功&quot;fi#处理编译文件目录的情况cd $upload_dirrm -rf ./buildbuildAppToDir=&quot;$upload_dir/build&quot; #编译打包完成后.app文件存放的目录#重新进入当前项目路径下cd $project_dirsecurity unlock-keychain -p &quot;addcn&quot; /Users/addcn/Library/Keychains/login.keychain#开始编译appif $isWorkSpace ; then  #判断编译方式    echo  &quot;开始编译workspace....&quot;     xcodebuild  -workspace $projectName -scheme $scheme  -configuration $configuration clean build SYMROOT=$buildAppToDirelse    echo  &quot;开始编译target....&quot;    xcodebuild  -target  $projectName  -configuration $configuration clean build SYMROOT=$buildAppToDirfi#判断编译结果if test $? -eq 0thenecho &quot;~~~~~~~~~~~~~~~~~~~编译成功~~~~~~~~~~~~~~~~~~~&quot;elseecho &quot;~~~~~~~~~~~~~~~~~~~编译失败~~~~~~~~~~~~~~~~~~~&quot;exit 1fiecho &quot;开始打包$scheme.app成$scheme.ipa.....&quot;cd $upload_dirfindFolderName=`find . -name &quot;$configuration-*&quot; -type d |xargs basename` #查找目录appDir=$buildAppToDir/$findFolderName  #app所在路径#重新进入当前项目路径下cd $project_direcho &quot;打包xarchive文件,路径为:$archive_path&quot;if $isWorkSpace ; then  #判断编译方式    echo  &quot;开始打包workspace....&quot;     xcodebuild -workspace $projectName -scheme $scheme -destination generic/platform=iOS archive -configuration ${configuration} ONLY_ACTIVE_ARCH=NO -archivePath $archive_pathelse    echo  &quot;开始打包target....&quot;    xcodebuild -target $projectName -scheme $scheme -destination generic/platform=iOS archive -configuration ${configuration} ONLY_ACTIVE_ARCH=NO -archivePath $archive_pathfi#检查文件是否存在if [ -a &quot;$archive_path&quot; ]; thenecho &quot;打包$scheme.xcarchive成功.&quot;elseecho &quot;打包$scheme.xcarchive失败.&quot;exit 1fi# echo &quot;开始导出$scheme.xcarchive成$scheme.ipa.....&quot;# xcodebuild -exportArchive -exportFormat ipa -archivePath $archive_path -exportPath $appDir/$ipa_name -exportProvisioningProfile $provisioningProfileNameecho &quot;开始打包$scheme.app成$scheme.ipa.....&quot;xcrun -sdk iphoneos PackageApplication -v $appDir/$scheme.app -o $appDir/$ipa_name #将app打包成ipaecho &quot;检查打包文件$appDir/${ipa_name}是否存在&quot;if [ -f &quot;$appDir/$ipa_name&quot; ];thenecho &quot;打包${ipa_name}成功.&quot;elseecho &quot;打包${ipa_name}失败.&quot;exit 1ficp -f -p $appDir/$ipa_name $ipa_path   #拷贝ipa文件echo &quot;复制${ipa_name}到${ipa_path}成功&quot;echo &quot;~~~~~~~~~~~~~~~~~~~结束打包，处理成功~~~~~~~~~~~~~~~~~~~&quot;#输出总用时echo &quot;===Finished.编译加打包共花费时间: ${SECONDS}s===&quot;echo &quot;正在上传至蒲公英平台&quot;echo &quot;版本:${bundleVersion}&quot;#蒲公英的ukey apikeycurl -F &quot;file=@${ipa_path}&quot; -F &quot;uKey=xxxxxxxxxxxxx&quot; -F &quot;_api_key=xxxxxxxxxxxxxxx&quot; https://www.pgyer.com/apiv1/app/upload &gt; $output_path/code.textresult=`cat $output_path/code.text`result1=`echo &quot;${result##*&quot;appQRCodeURL&quot;}&quot;`length=`expr ${#result1} - 6`result2=`echo ${result1:3:$length}`result3=`echo $result2 | sed &#39;s:\\\/:\/:g&#39;`if [ ! $result3 ];then   echo &quot;~~~~~~~~~~~~~~~~~~~上传失败~~~~~~~~~~~~~~~~~~~&quot;else   echo &quot;~~~~~~~~~~~~~~~~~~~上传成功~~~~~~~~~~~~~~~~~~~&quot;   echo &quot;生成的二维码链接为:${result3}&quot;fi# echo &quot;删除编译文件包和打包&quot;# rm -rf $buildAppToDir# rm -rf $output_path#输出总用时echo &quot;===Finished.共花费时间: ${SECONDS}s===&quot;</code></pre><h4 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h4><ol><li>构建任务<ol><li>选择新建任务</li><li>如建远程develop。保存名称为remove_develop 项目</li></ol></li></ol><p><img src="/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/2.png" alt="" loading="lazy"></p><ol start="2"><li>配置任务-源码管理</li></ol><p><img src="/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/3.png" alt="" loading="lazy"></p><ol start="3"><li>配置任务 - 定时触发器配置(可选)<a href="https://www.jianshu.com/p/509c59391b3b" target="_blank" rel="noopener">参考</a></li></ol><p><img src="/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/4.png" alt="" loading="lazy"></p><ol start="4"><li>配置任务 - 构建执行shell脚本命令</li></ol><p><img src="/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/5.png" alt="" loading="lazy"></p><h4 id="Jenkins配置结果"><a href="#Jenkins配置结果" class="headerlink" title="Jenkins配置结果"></a>Jenkins配置结果</h4><h5 id="项目任务建立-（本地dev-远程dev-远程master）"><a href="#项目任务建立-（本地dev-远程dev-远程master）" class="headerlink" title="项目任务建立 （本地dev 远程dev 远程master）"></a>项目任务建立 （本地dev 远程dev 远程master）</h5><p><img src="/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/6.png" alt="" loading="lazy"></p><h5 id="执行构建"><a href="#执行构建" class="headerlink" title="执行构建"></a>执行构建</h5><p><img src="/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/7.png" alt="" loading="lazy"></p><h5 id="执行历史"><a href="#执行历史" class="headerlink" title="执行历史"></a>执行历史</h5><p><img src="/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/8.png" alt="" loading="lazy"></p><h4 id="蒲公英平台"><a href="#蒲公英平台" class="headerlink" title="蒲公英平台"></a>蒲公英平台</h4><p><img src="/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/9.png" alt="" loading="lazy"></p><h2 id="局域网ip-端口访问失败"><a href="#局域网ip-端口访问失败" class="headerlink" title="局域网ip + 端口访问失败"></a>局域网ip + 端口访问失败</h2><blockquote><p>修改 </p></blockquote><ul><li>homebrew.mxcl.jenkins.plist 的 httpListenAddress 为 0.0.0.0<blockquote><p>目录地址</p></blockquote></li><li>~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist<blockquote><p>重启</p></blockquote></li><li>brew services stop jenkins</li><li>brew services start jenkins</li></ul><h2 id="打包失败"><a href="#打包失败" class="headerlink" title="打包失败"></a>打包失败</h2><blockquote><p>如报异常:<br>xcrun: error: unable to find utility “PackageApplication”, not a developer tool or in PATH<br>则根据如下链接操作:</p><ol><li>Xcode脚本自动化打包问题：xcrun: error: unable to find utility “PackageApplication”, not a developer tool or in PATH</li><li>后面根据对比发现新版的Xcode少了这个PackageApplication（转注：PackageApplication在前几个版本已被标识为废弃，在8.3版本彻底移除了）<br>先去找个旧版的Xcode里面copy一份过来</li><li>放到下面这个目录：<br>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/</li><li>然后执行命令：</li></ol><ul><li>sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer/</li><li>chmod +x /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/PackageApplication</li></ul></blockquote><ul><li>附上PackageApplication下载地址：</li><li><a href="https://pan.baidu.com/s/1jHJF2Lo" target="_blank" rel="noopener">https://pan.baidu.com/s/1jHJF2Lo</a></li><li><a href="https://www.cnblogs.com/Crazy-ZY/p/7115076.html" target="_blank" rel="noopener">参考链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jenkins-持续集成&quot;&gt;&lt;a href=&quot;#Jenkins-持续集成&quot; class=&quot;headerlink&quot; title=&quot;Jenkins 持续集成&quot;&gt;&lt;/a&gt;Jenkins 持续集成&lt;/h1&gt;&lt;h2 id=&quot;自动化打包分发&quot;&gt;&lt;a href=&quot;#自动化打包分
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Firebase的使用集合（二）</title>
    <link href="https://zhengzeqin.netlify.app/2018/12/06/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://zhengzeqin.netlify.app/2018/12/06/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2018-12-06T19:03:02.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程配置"><a href="#远程配置" class="headerlink" title="远程配置"></a><a href="https://firebase.google.com/docs/remote-config/" target="_blank" rel="noopener">远程配置</a></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Firebase 远程配置是一项云端服务，可让您更改应用的行为和外观，而无需用户下载应用更新。使用远程配置时，您可以创建应用内默认值，用于控制应用的行为和外观。之后，您便可以使用 Firebase 控制台或 Remote Config REST API，使得应用的所有用户或细分用户群获得不同于默认值的行为和外观。您的应用可控制何时安装更新，并能经常检查有无更新并安装更新，且对性能的影响微乎其微。<a href="https://juejin.im/post/5c08df4c6fb9a04a0c2e3e07" target="_blank" rel="noopener">掘金地址</a></p></blockquote><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>将更改快速发布至应用的用户群<ul><li>您可以通过更改服务端参数值来更改应用的默认行为和外观。</li><li>例如，您可以更改应用的布局或颜色主题背景以配合季节性促销，而无需发布应用更新。</li></ul></li><li>针对细分用户群量身打造应用<ul><li>您可以使用远程配置为不同的细分用户群（按应用版本、按 Google Analytics for Firebase 受众群体、按语言及更多因素划分）提供多样化的应用用户体验。</li></ul></li><li>运行 A/B 测试以改进您的应用<ul><li>您可以结合使用远程配置随机百分位定位和 Google Analytics for Firebase，在不同的细分用户群中针对应用的改进之处进行 A/B 测试，以便能够先验证这些改进之处，然后再将其推向整个用户群。</li></ul></li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><pre><code>//通过Cocopod导入pod &#39;Firebase/RemoteConfig&#39;，</code></pre><blockquote><p>与performance一样，默认会在[FIRApp configure]; 初始化 <br></p></blockquote><p>&lt;!–&gt; -FIRAnalyticsDebugDisabled–&gt;</p><!---FIRAnalyticsDebugEnabled--><p><img src="/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" alt="" loading="lazy"></p><blockquote><p>Firebase   DebugView调试部分 <br><br>[√] FIRAnalyticsDebugDisabled : 调试关闭<br><br>[√] FIRAnalyticsDebugEnabled : 调试打开<br></p></blockquote><h4 id="创建参数及条件"><a href="#创建参数及条件" class="headerlink" title="创建参数及条件"></a>创建参数及条件</h4><p><img src="/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" alt="" loading="lazy"></p><p>Parameters ：参数列表</p><ul><li>设定参数的指定条件</li><li>限制最多2000个参数</li></ul><p>Conditions ：条件列表</p><ul><li>Remote Config 提供多种条件选项，比如操作系统,语言，国家地区，目标对象…</li><li>限制最多 500个条件</li></ul><p>Parameters和Conditions的限制</p><ul><li>参数键最多可包含 256 个字符，且必须以下划线或英文字母（A-Z、a-z）开头，还可以包含数字。一个项目中所有参数值字符串的总长度不能超过 80 万个字符</li></ul><blockquote><p><a href="https://firebase.google.com/docs/remote-config/parameters" target="_blank" rel="noopener">我们配置app_color这个参数，支持json字符串</a><br><br> [[FIRRemoteConfig remoteConfig]configValueForKey:@”app_color”]</p></blockquote><h4 id="app获取远程配置好的数据"><a href="#app获取远程配置好的数据" class="headerlink" title="app获取远程配置好的数据"></a>app获取远程配置好的数据</h4><pre><code>- (void)firebaseRemoteConfigure{    //过期时间。默认设置为60分钟    NSTimeInterval duration = 3600;#if DEBUG    //配置设置，是否打开调试模式    FIRRemoteConfigSettings *setting = [[FIRRemoteConfigSettings alloc]initWithDeveloperModeEnabled:YES];    [FIRRemoteConfig remoteConfig].configSettings = setting;    //这边测试调试，所以设置为0分钟    duration = 0;#endif    // 设置60分钟触发更新  3600    [[FIRRemoteConfig remoteConfig] fetchWithExpirationDuration:duration completionHandler:^(FIRRemoteConfigFetchStatus status, NSError * _Nullable error) {        if(!error){            DLog(@&quot;FIRRemoteConfigstatus = %d&quot;,status);            BOOL activateFetched = [[FIRRemoteConfig remoteConfig]activateFetched];            if (activateFetched) {            //获取服务端的值                FIRRemoteConfigValue *value = [[FIRRemoteConfig remoteConfig] configValueForKey:@&quot;app_color&quot;];                DLog(@&quot;FIRRemoteConfigvalue = %@, %@&quot;,value.dataValue,value.stringValue);            }        }    }];}</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>fetchWithExpirationDuration:completionHandler: 使用 (默认情况下，缓存在 12 小时后失效)<br><br>需限制是在 60 分钟的时间段内最多可以提取 5次。否则如果您的应用多次使用 fetchWithExpirationDuration:completionHandler: 请求刷新值，请求会遭到阻止，并向您的应用提供缓存的值。 <a href="https://firebase.google.com/docs/remote-config/ios?authuser=0#caching_and_throttling" target="_blank" rel="noopener">参考</a></li><li>使用远程配置模板时，请注意以下要求：这些模板有不同的版本，每个版本的有效期均为 90 天（从创建之日起到将其替换为更新版本为止），而存储的版本总数不超过 300 个</li></ul><h2 id="A-B-Test"><a href="#A-B-Test" class="headerlink" title="A/B Test"></a><a href="https://firebase.google.com/docs/ab-testing/" target="_blank" rel="noopener">A/B Test</a></h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Firebase A/B 测试可让您轻松地运行、分析和扩展产品和营销实验，从而帮助您改进应用。它使您能够测试应用界面、功能或互动广告系列的更改，以确认这些更改是否确实使关键指标（如收入和用户留存率）较更改前有所改观。</p></blockquote><h3 id="支持两种测试方式"><a href="#支持两种测试方式" class="headerlink" title="支持两种测试方式"></a>支持两种测试方式</h3><ul><li><a href="https://firebase.google.com/docs/ab-testing/abtest-config?authuser=0" target="_blank" rel="noopener">创建远程配置实验</a></li><li><a href="https://firebase.google.com/docs/ab-testing/abtest-with-console?authuser=0" target="_blank" rel="noopener">创建消息传递实验</a></li></ul><h3 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>运行测试并提升您的产品使用体验<ul><li>通过远程配置创建实验，在实验的变体中更改应用的行为和外观，并测试哪种产品使用体验能最有效地带来您最关注的效果。</li></ul></li><li>使用通知编辑器寻找再次吸引用户的方法<ul><li>使用 A/B 测试帮助您找出最有效的措辞和消息设置来吸引用户使用您的应用。</li></ul></li><li>安全推出新功能<ul><li>要推出新功能，首先必须在一小部分用户身上进行测试，确保其符合您的目标。等到对 A/B 测试结果有了信心后，再面向全部用户推出功能。</li></ul></li><li>定位“预测”的用户群<ul><li>借助 Firebase 预测功能，您可以针对预计会执行特定操作的用户运行 A/B 测试，这类操作包括花钱消费（或不花钱）、停止使用您的应用，以及执行您通过 Analytics 定义的任何其他转化事件等。</li></ul></li></ul><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><pre><code>//通过Cocopod导入pod &#39;FirebaseABTesting&#39;</code></pre><blockquote><p>默认会在[FIRApp configure]; 初始化 <br><br>通过远程配置方式获取参数数据代码参考RemoteConfig部分</p></blockquote><h4 id="创建A-B-TEST实验"><a href="#创建A-B-TEST实验" class="headerlink" title="创建A/B TEST实验"></a>创建A/B TEST实验</h4><blockquote><p>创建remote_a/b_test实例</p></blockquote><p><img src="/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" alt="" loading="lazy"></p><blockquote><p>创建测试条件及参数</p></blockquote><ul><li>控制组，Variant A  两组数据</li></ul><p><img src="/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" alt="" loading="lazy"></p><blockquote><p>测试配置执行的ID凭证</p></blockquote><ul><li>ID凭证即是fcmToken</li></ul><p><img src="/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" alt="" loading="lazy"></p><blockquote><p>通过远程配置的方式获取到参数条件</p></blockquote><ul><li>参考Remote Configure 远程配置方式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;远程配置&quot;&gt;&lt;a href=&quot;#远程配置&quot; class=&quot;headerlink&quot; title=&quot;远程配置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://firebase.google.com/docs/remote-config/&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>移动端性能标准值及定义整理</title>
    <link href="https://zhengzeqin.netlify.app/2018/11/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%A7%E8%83%BD%E6%A0%87%E5%87%86%E5%80%BC%E5%8F%8A%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86/"/>
    <id>https://zhengzeqin.netlify.app/2018/11/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%A7%E8%83%BD%E6%A0%87%E5%87%86%E5%80%BC%E5%8F%8A%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86/</id>
    <published>2018-11-22T19:03:01.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>这个月Boss需要我们整理一份各个性能采集后的参考值，对于崩溃的数据采集，我们接入有Bugly,友盟。对于性能采集我们接入的是<a href="https://firebase.google.com/products/performance/" target="_blank" rel="noopener">Firebase Performace</a> </p></blockquote><h2 id="591的性能指标"><a href="#591的性能指标" class="headerlink" title="591的性能指标"></a>591的性能指标</h2><p><img src="/images/2018/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%A7%E8%83%BD%E6%A0%87%E5%87%86%E5%80%BC%E5%8F%8A%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86/1.png" alt="" loading="lazy"></p><h3 id="指标说明"><a href="#指标说明" class="headerlink" title="指标说明"></a>指标说明</h3><blockquote><p>日报使用：崩溃率（友盟最新版）、启动时间（Performance）<br><br>统计使用：崩溃率（友盟最新版）、用户崩溃率（友盟最新版）、ANR率/卡顿率（bugly最新版）、启动时间（Performance）、網路呼叫成功率（Performance）<br><br>崩溃率的定义：友盟比较符合大多数人的理解<br><br>参考值的定义：崩溃率和启动时间，虽然有找到一些参考值，不过对比之后显示我们的数据非常好（原因是平台统计数据为业内平均值），所以我们依据591近期的数据和自我要求，定义了一个参考值（如上日报）<br><br>其它：用户崩溃率、ANR率/卡顿率、網路呼叫成功率，对于App的性能评估也有一定的作用，不过日报里面建议先不添加，避免太多内容</p></blockquote><h2 id="App性能指标定义"><a href="#App性能指标定义" class="headerlink" title="App性能指标定义"></a>App性能指标定义</h2><table style="word-wrap:break-word;text-align:center">    <tr>        <td>平台</td>         <td> 名称</td>         <td >计算方式</td>         <td >描述</td>     </tr>    <tr>        <td rowspan="2" >友盟</td>            <td >崩溃率/错误率</td>          <td >崩溃次数/启动次数</td>        <td style="text-align:left">1.崩溃次数/错误次数：<br>该类错误在一定时间范围内产生的次数，也就是SDK上报的日志数量 <br> 2.启动次数:<br> 1).Android：启动是通过在所有activity中调用MobclickAgent.onResume() 和MobclickAgent.onPause()方法来监测的<br>2).iOS：进入后台即算是当前统计会话结束。当再次进入前台时，算作一次新的启动行为，<br>并开始新的统计会话</td>    </tr>    <tr>        <td >用户崩溃率</td>          <td >影响用户/活跃用户</td>         <td style="text-align:left">1.影响用户数：在一定时间范围内对该类错误的所有错误日志按照设备维度进行排重计数 <br> 2.活跃用户：所选时间段内，启动过应用的用户(去重)，启动过一次的用户即被视为活跃用户，包括新用户和老用户。</td>    </tr>    <tr>        <td rowspan="4">Bugly</td>            <td >次数崩溃率</td>          <td >发生次数/联网次数</td>         <td style="text-align:left">1.发生次数：一个异常发生且被记录上报，计为一次异常发生。<br>2.联网次数：即 启动次数+跨天联网次数。<br>3.跨天联网：用户没有启动应用，只有应用进程在后台运行，且超过零点，计为一次跨天联网。<br>4.启动次数：以下场景均计为一次启动<br>1).应用完全退出后重新启动，计为一次启动；<br>2).应用被切换至后台后，30秒后被切换至前台，计为一次启动，若未超过30秒切换至前台，不算一次启动。</td>     </tr>    <tr>        <td >用户崩溃率</td>          <td >影响用户/活跃用户</td>         <td style="text-align:left">1.影响用户数：在一定时间范围内对该类错误的所有错误日志按照设备维度进行排重计数 <br> 2.活跃用户：所选时间段内，启动过应用的用户(去重)，启动过一次的用户即被视为活跃用户，包括新用户和老用户。</td>    </tr>    <tr>        <td nowrap="nowrap">次数ANR率/卡顿率</td>          <td nowrap="nowrap">发生次数/联网次数</td>         <td >同上次数崩溃率描述</td>    </tr>    <tr>        <td >用户ANR率/卡顿率</td>          <td >影响用户/联网用户</td>         <td >同上用户崩溃率描述</td>    </tr>    <tr>        <td rowspan="2" nowrap="nowrap">Performace</td>            <td >启动时间</td>         <td >從程式碼初始化 - 使用者介面有所回應為止</td>        <td > <a href= "https://firebase.google.com/docs/perf-mon/automatic?authuser=0">定义</a><br>1.iOS:在应用将第一个 Object 加载到内存时开始，第一个 run loop 成功（应用收到 UIApplicationDidBecomeActiveNotification 通知后）时停止。<br>2.Android:在应用的 FirebasePerfProvider ContentProvider 完成其 onCreate 方法时开始，第一个 Activity 的 onResume() 方法被调用时停止。</td>    </tr>    <tr>        <td >網路呼叫成功率 </td>         <td >成功响应次数/总响应次数</td>        <td > 由傳回 2xx 或 3xx 回應代碼的應用程式提出的 HTTP/S 要求百分比。如需查看詳細資訊，請前往「網路要求」分頁</td>    </tr>        <tr>        <td rowspan="2" nowrap="nowrap">GooglePlay</td>            <td >當機率</td>         <td >无</td>        <td > 使用者遇到至少1次當機情形的每日工作階段百分比。每日工作階段是指使用者一天內使用應用程式的時間</td>    </tr>    <tr>        <td >ANR 发生率 </td>         <td >无</td>        <td > 使用者遇到至少 1 次 ANR 情形的每日工作階段百分比。每日工作階段是指使用者一天內使用應用程式的時間。</td>    </tr>    <tr>        <td nowrap="nowrap">App Store Connect </td>         <td >崩溃率</td>        <td > 崩溃次数/使用次数</td>        <td >目前appstore 统计是限参与统计用户<br>计算方式是 = 崩溃次数/使用次数 （使用次数:使用时间超过2s的次数）附:仅限参与统计用户</td>    </tr></table><h2 id="App性能指标业内参考值"><a href="#App性能指标业内参考值" class="headerlink" title="App性能指标业内参考值"></a>App性能指标业内参考值</h2><table style="text-align:center">    <tr >        <td rowspan="2">名称</td>          <td colspan="3">业内参考值</td>    </tr>    <tr>        <td>iOS</td>         <td>Android</td>         <td>数据来源</td>    </tr>    <tr>        <td rowspan="8">崩溃率</td>            <td >1.01%</td>          <td >0.2%</td>        <td >听云16年报告 - 年平均崩溃率</td>    </tr>    <tr>        <td>0.93%</td>         <td>0.13%</td>         <td >听云15年报告 - 年平均崩溃率</td>    </tr>    <tr>        <td>0.78%</td>         <td>1.89%</td>         <td >听云17年报告 - 房产中介 - 年平均崩溃率</td>    </tr>    <tr>        <td>0.79%</td>         <td>0.17%</td>         <td >听云17年报告 - 工具 - 年平均崩溃率</td>    </tr>    <tr>        <td>0.38%</td>         <td>0.09%</td>         <td >听云16年报告 - 软件工具 - 年平均崩溃率</td>    </tr>    <tr>        <td nowrap="nowrap">优秀值0.3%<br>标准值0.8%</td>         <td nowrap="nowrap">优秀值0.2%<br>标准值0.4%</td>         <td ><a href= "https://blog.csdn.net/x32sky/article/details/52778169">来自14年的听云报告</a><br>根据统计数据显示，当iOS的崩溃率超过0.8%，Android的崩溃率超过0.4%的时候，活跃用户有明显下降态势。</td>    </tr>    <tr>        <td>2.96%</td>         <td>2.86%</td>         <td ><a href= "https://blog.csdn.net/f2006116/article/details/55504714">bugly2016 移动应用质量大数据报告-平均崩溃率</a></td>    </tr>    <tr>        <td colspan="2">优秀：0.03%</td>          <td>一些开发群中开发者的回复（滴滴，美团）</td>     </tr>    <tr>        <td nowrap="nowrap">ANR率/卡顿率</td>         <td>-</td>         <td>1.09%</td>         <td>GooglePlay的不良行为门槛</td>     </tr>    <tr>        <td>用户ANR率</td>         <td>-</td>         <td>0.47%</td>         <td>GooglePlay的不良行为门槛</td>     </tr>    <tr>        <td>启动时间</td>         <td colspan="2">5s</td>        <td>Performance标准值</td>     </tr>    <tr>        <td>網路呼叫成功率</td>         <td>97.45%</td>         <td>95.48%</td>         <td>听云17年报告 - 年平均 HTTP 请求成功率</td>     </tr>    <tr>        <td rowspan="2">响应时间</td>         <td>417.99ms</td>         <td>439.65ms</td>         <td>听云17年报告 - 房产中介 - 年平均响应时间</td>     </tr>    <tr>        <td>652.69ms</td>         <td>617.19ms</td>         <td>听云17年报告 - 工具 - 年平均响应时间</td>     </tr></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h3 id="友盟定义参考"><a href="#友盟定义参考" class="headerlink" title="友盟定义参考"></a>友盟定义参考</h3><ul><li><a href="https://developer.umeng.com/docs/67953/detail/67989#h1-u542Fu52A8u6B21u65703" target="_blank" rel="noopener">用户描述文档：</a></li><li><a href="https://developer.umeng.com/docs/67953/detail/68133" target="_blank" rel="noopener">错误描述文档：</a></li></ul><h3 id="Bugly定义参考"><a href="#Bugly定义参考" class="headerlink" title="Bugly定义参考"></a>Bugly定义参考</h3><ul><li><a href="https://bugly.qq.com/docs/introduction/bugly-introduction/?v=20180709165613#_6" target="_blank" rel="noopener">描述文档：</a></li></ul><h3 id="Preformace"><a href="#Preformace" class="headerlink" title="Preformace"></a>Preformace</h3><ul><li><a href="https://support.google.com/firebase/answer/6318039?hl=zh-Hans" target="_blank" rel="noopener">Firebase 性能监控的数据收集</a></li></ul><h3 id="听云"><a href="#听云" class="headerlink" title="听云"></a>听云</h3><ul><li><a href="https://www.tingyun.com/awr_mobile.html" target="_blank" rel="noopener">听云移动应用性能管理白皮书</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这个月Boss需要我们整理一份各个性能采集后的参考值，对于崩溃的数据采集，我们接入有Bugly,友盟。对于性能采集
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Firebase的使用集合</title>
    <link href="https://zhengzeqin.netlify.app/2018/11/21/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <id>https://zhengzeqin.netlify.app/2018/11/21/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/</id>
    <published>2018-11-21T19:03:03.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h1><blockquote><p>Firebase是一家实时后端数据库创业公司，它能帮助开发者很快的写出Web端和移动端的应用。自2014年10月Google收购Firebase以来，用户可以在更方便地使用Firebase的同时，结合<a href="https://firebase.google.cn/" target="_blank" rel="noopener">Google的云服务</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为我们公司是用户群是在台湾，所以在第三方库的选型上选择了Firebase。因为它拥有较丰富的第三方库集。</p><h2 id="基础接入"><a href="#基础接入" class="headerlink" title="基础接入"></a>基础接入</h2><ol><li>创建Firebase开发者账户<a href="https://www.firebase.com/login/" target="_blank" rel="noopener">注册地址</a></li><li>安装Firebase.framework<br>通过Cocopod 安装<pre><code>pod &#39;Firebase/Core&#39;</code></pre></li><li>添加Firebase配置文件 <a href="https://firebase.google.com/docs/ios/setup?authuser=0" target="_blank" rel="noopener">将 Firebase 添加到您的 iOS 项目</a></li></ol><ul><li>在控制台中创建项目后，下载配置文件GoogleService-Info.plist，移动加入项目中</li><li>在didFinishLaunchingWithOptions 初始化firebase</li></ul><pre><code>[FIRApp configure]; </code></pre><h4 id="目前支持Firebase服务有"><a href="#目前支持Firebase服务有" class="headerlink" title="目前支持Firebase服务有"></a>目前支持Firebase服务有</h4><table><thead><tr><th>pod</th><th>服务</th></tr></thead><tbody><tr><td>pod ‘Firebase/Core’</td><td>必备库和 Analytics</td></tr><tr><td>pod ‘Firebase/AdMob’</td><td>AdMob</td></tr><tr><td>pod ‘Firebase/Messaging’</td><td>必备库和 Analytics</td></tr><tr><td>pod ‘Firebase/AdMob’</td><td>AdMob</td></tr><tr><td>pod ‘Firebase/Database’</td><td>实时数据库</td></tr><tr><td>pod ‘Firebase/Invites’</td><td>邀请</td></tr><tr><td>pod ‘Firebase/DynamicLinks’</td><td>动态链接</td></tr><tr><td>pod ‘Fabric’，pod ‘Crashlytics’</td><td>Crashlytics</td></tr><tr><td>pod ‘Firebase/RemoteConfig’</td><td>远程配置</td></tr><tr><td>pod ‘Firebase/Auth’</td><td>身份验证</td></tr><tr><td>pod ‘Firebase/Storage’</td><td>存储</td></tr><tr><td>pod ‘Firebase/Performance’</td><td>性能监控</td></tr><tr><td>pod ‘Firebase/Firestore’</td><td>Cloud Firestore</td></tr><tr><td>pod ‘Firebase/Functions’</td><td>Cloud Functions for Firebase 客户端 SDK</td></tr><tr><td>pod ‘Firebase/MLVision’</td><td>ML Kit Vision API</td></tr><tr><td>pod ‘Firebase/MLVisionLabelModel’</td><td>机器学习套件（基于设备的标签检测）</td></tr><tr><td>pod ‘Firebase/MLVisionBarcodeModel’</td><td>机器学习套件（基于设备的条形码扫描）</td></tr><tr><td>pod ‘Firebase/MLVisionTextModel’</td><td>机器学习套件（基于设备的文字识别）</td></tr><tr><td>pod ‘Firebase/MLVisionFaceModel’</td><td>机器学习套件（基于设备的面部检测）</td></tr></tbody></table><h2 id="基于Firebase下的GA统计"><a href="#基于Firebase下的GA统计" class="headerlink" title="基于Firebase下的GA统计"></a>基于Firebase下的GA统计</h2><p>1.配合GTM SDK 将firebase采集到的数据发送到Google Analytics中</p><blockquote><p>添加GTM SDK 与 Google Analytics SDK</p></blockquote><pre><code>pod &#39;GoogleIDFASupport&#39;  // Google Analytics pod &#39;GoogleTagManager&#39;   // GTM SDK</code></pre><ul><li>登录GTM的平台 <a href="https://tagmanager.google.com/?hl=zh_CN#/org/xM83TFWlQfiVaBKyzHY6Zw" target="_blank" rel="noopener">地址</a></li></ul><p><img src="/images/2018/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/1.png" alt="" loading="lazy"></p><ul><li>创建触发器</li></ul><p><img src="/images/2018/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/2.png" alt="" loading="lazy"></p><ul><li>创建代码  GA-ID变量即是 我们的Google Analytics平台的ID</li></ul><p><img src="/images/2018/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/3.png" alt="" loading="lazy"></p><blockquote><p>简述：我们先在 GTM container 网页上设定想追踪的 tag（标籤），每个 tag 会包含一个 trigger（触发条件），当 Firebase 发送事件后 GTM 会去比对这个事件是不是符合某个 tag 的触发条件，在这次的例子中就会将数据发送到 GA 报表上。触发条件比较灵活，可以自定义。包括维度的划分。这里就不再详细介绍。</p></blockquote><blockquote><p>firebase的发送函数是</p></blockquote><pre><code>//触发器事件名称#define Event_Trigger    @&quot;event_trigger_str&quot;// 统计类别#define Event_Category    @&quot;event_category_str&quot;// 统计动作#define Event_Action    @&quot;event_action_str&quot;// 统计标签#define Event_Label    @&quot;event_label_str&quot;// 即可将统计事件发送到GA中              + (void)fireBaseEvent:(NSString *)category               action:(NSString *)action                label:(NSString *)label{    [FIRAnalytics logEventWithName:Event_Param_Trigger parameters:@{Event_Param_Category:category,Event_Param_Action:action,Event_Param_Label:label}];}           </code></pre><h2 id="FCM推送"><a href="#FCM推送" class="headerlink" title="FCM推送"></a>FCM推送</h2><ol><li>通过cocopod库设置Fcm sdk, fcm 中支持<a href="https://firebase.google.com/docs/cloud-messaging/concept-options?authuser=0" target="_blank" rel="noopener">通知消息和数据消息</a></li><li>在”专案设置-设置-Cloud Messaging”中上传开发者凭证到fcm平台</li></ol><p><img src="/images/2018/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/4.png" alt="" loading="lazy"></p><ol start="3"><li>配置代码如下</li></ol><pre><code>//通过Cocopod导入pod &#39;Firebase/Messaging&#39;</code></pre><pre><code>// 第一步设置代理- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{    //配置FCM 代理    [FIRMessaging messaging].delegate = self;}- (void)applicationDidEnterBackground:(UIApplication *)application {    [self disconnectToFCM];}- (void)applicationDidBecomeActive:(UIApplication *)application{    [self connectToFCM];}// 注册TOKEN- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken{   #if DEBUG    [[FIRMessaging messaging] setAPNSToken:deviceToken type:FIRMessagingAPNSTokenTypeSandbox];    #else    [[FIRMessaging messaging] setAPNSToken:deviceToken type:FIRMessagingAPNSTokenTypeProd];    #endif}#pragma mark - RemoteMessage Connect// 链接fcm- (void)connectToFCM{    NSString *refreshedToken = [[FIRInstanceID instanceID] token];    DLog(@&quot;InstanceID token: %@&quot;, refreshedToken);    [FIRMessaging messaging].shouldEstablishDirectChannel = YES;}// 断开fcm- (void)disconnectToFCM{    [FIRMessaging messaging].shouldEstablishDirectChannel = NO;}#pragma mark - FIRMessagingRemoteMessage Delegate//获取fcmtoken回调函数- (void)messaging:(nonnull FIRMessaging *)messaging didReceiveRegistrationToken:(nonnull NSString *)fcmToken{    DLog(@&quot;didReceiveRegistrationToken fcmToken = %@&quot;,fcmToken);    [self connectToFCM];    // 注意 将fcm 发送到自己的后端采集token及用户的设备id,用于发送推送    // .......}//注意：fcm data 数据消息的接收回调，如果是通知消息回调，走的是Apple 的api此处不详述//ios10 之前didReceiveRegistrationToken- (void)applicationReceivedRemoteMessage:(nonnull FIRMessagingRemoteMessage *)remoteMessage{    DLog(@&quot;RemoteMessageDeleagte remoteMessage = %@&quot;,remoteMessage);}//iOS10 及之后- (void)messaging:(nonnull FIRMessaging *)messaging didReceiveMessage:(nonnull FIRMessagingRemoteMessage *)remoteMessage{    DLog(@&quot;RemoteMessageDeleagte didReceiveMessage = %@&quot;,remoteMessage);//fcm data 数据没有带前缀gcm.notification.}</code></pre><h2 id="Performace监控"><a href="#Performace监控" class="headerlink" title="Performace监控"></a>Performace监控</h2><p><img src="/images/2018/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/5.png" alt="" loading="lazy"></p><p>firebase 的performance能采集到数据有<a href="https://support.google.com/firebase/answer/6318039?hl=zh-Hans" target="_blank" rel="noopener">链接</a></p><ul><li>启动速度</li><li>网络呼叫成功率</li><li>網路回應 MIME 類型</li><li>網路回應延遲時間</li><li>不同畫面的顯示速度緩慢資料 （可以自定义采集内容）<pre><code>//通过Cocopod导入pod &#39;Firebase/Performance&#39;</code></pre><blockquote><p>performance 只要解决导入库,即可。默认会在[FIRApp configure]; 已初始化</p></blockquote></li></ul><h4 id="关于自定义采集-page-speed"><a href="#关于自定义采集-page-speed" class="headerlink" title="关于自定义采集 page_speed"></a>关于自定义采集 page_speed</h4><p><img src="/images/2018/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/6.png" alt="" loading="lazy"></p><pre><code>// 自定义采集是通过setValue:forAttribute 方式设置采集属性及值+ (void)performaceLoadTimeWithName:(NSString *)name comeDate:(NSDate *)comeDate{        FIRTrace *trace = [FIRPerformance startTraceWithName:name];        NSTimeInterval time = fabs([comeDate timeIntervalSinceNow]);        [trace setValue:[NSString stringWithFormat:@&quot;%.2f秒&quot;,time] forAttribute:@&quot;page_speed&quot;];        DLog(@&quot;PageName = %@,时间差(秒) = %.2f&quot;,name,time);        [trace stop];}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Firebase&quot;&gt;&lt;a href=&quot;#Firebase&quot; class=&quot;headerlink&quot; title=&quot;Firebase&quot;&gt;&lt;/a&gt;Firebase&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Firebase是一家实时后端数据库创业公司，它能帮助开发者很快的
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>公司夺旗比赛-iOS题</title>
    <link href="https://zhengzeqin.netlify.app/2018/11/21/%E5%85%AC%E5%8F%B8%E5%A4%BA%E6%97%97%E6%AF%94%E8%B5%9B-iOS%E9%A2%98/"/>
    <id>https://zhengzeqin.netlify.app/2018/11/21/%E5%85%AC%E5%8F%B8%E5%A4%BA%E6%97%97%E6%AF%94%E8%B5%9B-iOS%E9%A2%98/</id>
    <published>2018-11-21T19:02:59.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>公司每年的6月份会举办一场夺旗大赛，作为读书会的小组成员。我就负责出了一份比较简单的iOS题<br><a href="https://juejin.im/post/5bf4b76af265da61602c8ddd" target="_blank" rel="noopener">掘金地址</a></p></blockquote><h2 id="CTF移动端题目"><a href="#CTF移动端题目" class="headerlink" title="CTF移动端题目"></a>CTF移动端题目</h2><h3 id="1-灰原同学提出可以查看监控，但监控室的门是用密码锁上的，门上只有了一串英文字母MjM4MzIxNDE0Mg-你可以帮助少年侦探团打开门吗？"><a href="#1-灰原同学提出可以查看监控，但监控室的门是用密码锁上的，门上只有了一串英文字母MjM4MzIxNDE0Mg-你可以帮助少年侦探团打开门吗？" class="headerlink" title="1.灰原同学提出可以查看监控，但监控室的门是用密码锁上的，门上只有了一串英文字母MjM4MzIxNDE0Mg==,你可以帮助少年侦探团打开门吗？"></a>1.灰原同学提出可以查看监控，但监控室的门是用密码锁上的，门上只有了一串英文字母MjM4MzIxNDE0Mg==,你可以帮助少年侦探团打开门吗？</h3><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><pre><code>base64解码得到2383214142 通过手机键盘-九宫格得到答案 CVAGH</code></pre><h3 id="2-在暗格门里发现作案者留下的文件包，但是却需要账户和密码才能打开，通过下面的代码和文件你能帮助柯南找出答案吗？"><a href="#2-在暗格门里发现作案者留下的文件包，但是却需要账户和密码才能打开，通过下面的代码和文件你能帮助柯南找出答案吗？" class="headerlink" title="2.在暗格门里发现作案者留下的文件包，但是却需要账户和密码才能打开，通过下面的代码和文件你能帮助柯南找出答案吗？"></a>2.在暗格门里发现作案者留下的<a href="https://pan.baidu.com/s/1nxddHhFBr8BjTJkoZn5a-w" target="_blank" rel="noopener">文件包</a>，但是却需要账户和密码才能打开，通过下面的代码和文件你能帮助柯南找出答案吗？</h3><pre><code>@interface MyAccount : NSObject @property (nonatomic, copy) NSString *flag;@end@implementation MyAccount@end</code></pre><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><pre><code>1、.m文件实现NSCoding协议，补充代码如下#import &quot;MyAccount.h&quot;@interface MyAccount()&lt;NSCoding&gt;@end@implementation MyAccount- (void)encodeWithCoder:(NSCoder *)aCoder{    [aCoder encodeObject:self.flag forKey:@&quot;flag&quot;];}- (id)initWithCoder:(NSCoder *)decoder {    if (self = [super init]) {        _flag = [decoder decodeObjectForKey:@&quot;flag&quot;];    }    return self;}@end2、导入data包，NSKeyedUnarchiver解档对象，得到flag: c2h1aXJ1aWtlamljdGY=NSString *dataFile = [[NSBundle mainBundle]pathForResource:@&quot;data&quot; ofType:@&quot;asd&quot;];MyAccount *model = [NSKeyedUnarchiver unarchiveObjectWithFile:dataFile];NSLog(@&quot;dataFile = %@&quot;,model.flag);3、使用base64解码得到答案： shuiruikejictf</code></pre><h3 id="3-侦探少年团解答出账户和密码后并打开文件包后，发现盗贼留下了一份挑战书“你想要的密码就在我的ipa包中”，你能从MySercretKey-ipa包中读取到答案吗？"><a href="#3-侦探少年团解答出账户和密码后并打开文件包后，发现盗贼留下了一份挑战书“你想要的密码就在我的ipa包中”，你能从MySercretKey-ipa包中读取到答案吗？" class="headerlink" title="3.侦探少年团解答出账户和密码后并打开文件包后，发现盗贼留下了一份挑战书“你想要的密码就在我的ipa包中”，你能从MySercretKey.ipa包中读取到答案吗？"></a>3.侦探少年团解答出账户和密码后并打开文件包后，发现盗贼留下了一份挑战书“你想要的密码就在我的ipa包中”，你能从<a href="https://pan.baidu.com/s/1YiNuM3bLXj4-C_2jUsU9Gw" target="_blank" rel="noopener">MySercretKey.ipa</a>包中读取到答案吗？</h3><h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><pre><code>使用Hopper Disassembler工具反编译如下图读取到flag = U2FsdGVkX18wjamzHeMlywW3nE/EPSImPYlN25ihcf0=decode = shurui使用AES 解密（密钥shurui）答案:flag = asdxczcsa</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;公司每年的6月份会举办一场夺旗大赛，作为读书会的小组成员。我就负责出了一份比较简单的iOS题&lt;br&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
      <category term="addcn" scheme="https://zhengzeqin.netlify.app/tags/addcn/"/>
    
  </entry>
  
  <entry>
    <title>OC和Swift混编经验</title>
    <link href="https://zhengzeqin.netlify.app/2018/09/10/OC%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E7%BB%8F%E9%AA%8C/"/>
    <id>https://zhengzeqin.netlify.app/2018/09/10/OC%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E7%BB%8F%E9%AA%8C/</id>
    <published>2018-09-10T19:03:02.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swift简介"><a href="#Swift简介" class="headerlink" title="Swift简介"></a>Swift简介</h2><blockquote><p>Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与Objective-C*共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。<br>2015年12月4日，苹果公司宣布其Swift编程语言现在开放<a href="https://github.com/apple/swift" target="_blank" rel="noopener">源代码</a>。<br><a href="https://juejin.im/post/5b9650c35188255c8a05dd94" target="_blank" rel="noopener">掘金地址</a></p></blockquote><h2 id="Swift-优势"><a href="#Swift-优势" class="headerlink" title="Swift 优势"></a>Swift 优势</h2><h3 id="简洁代码"><a href="#简洁代码" class="headerlink" title="简洁代码"></a>简洁代码</h3><blockquote><ol><li>Swift所有的变量定义使用var ,常量定义使用let。</li><li>数组或字符串可以使用”+”符号直接相加。</li><li>可以使用高阶函数map，flatMap，reduce，filter简化代码量。</li></ol></blockquote><h3 id="易维护"><a href="#易维护" class="headerlink" title="易维护"></a>易维护</h3><blockquote><ol><li>Swift抛弃了OC头文件（.h）和实现文件（.m）组合成一个代码文件（.swift）。</li><li>因为Swift不是基于C构建的，而OC是在C和Smalltalk下构建。所以在设计上比较新颖，同时我们能看到现代语言（JavaScript，Java，Python，C#，以及 C++ ）的身影特性：泛型，可选类型，类型推断，高阶函数。基于泛型和高阶函数的使用导致更清晰，更可重用的代码，更易于维护。</li></ol></blockquote><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><blockquote><ol><li>在OC中不同类型可以直接相加，默认会隐式转换。但是swift不同类型的是不能直接相加，必须先进行类型转换。</li><li>在其他的编程语言当中，你并不能知道哪个变量可以为空(null)哪个不能，这就强制开发者去考虑可能为空的情况。</li><li>在OC中if判断存在非0即是true的方式，但是在swift中if判断必须为true或者false。</li></ol></blockquote><h3 id="快"><a href="#快" class="headerlink" title="快"></a>快</h3><blockquote><ol><li>OC是一门动态的语言，很多实际执行需要在运行时才可以确定，Swift不一样，Swift将很多在运行时才可以确定的信息，在编译期就决定了。这就让Swift更加快速。<a href="https://onevcat.com/2016/02/swift-performance/" target="_blank" rel="noopener">Swift性能探索和优化分析-王巍</a></li><li>在纯Swift中的函数调用就不是OC的那套runtime了，而是类似C++的vtable，在编译期就决定调用哪个函数。那如果想使用OC的特性需要继承自NSObject。</li></ol></blockquote><h2 id="Swift-与-OC-的混编"><a href="#Swift-与-OC-的混编" class="headerlink" title="Swift 与 OC 的混编"></a>Swift 与 OC 的混编</h2><blockquote><ol><li>当我们在OC项目中添加Swift文件的时候系统会默认帮我创建一个桥接文件。<br>“项目名称-Bridging-Header.h”的文件。</li><li>在Swift中调用OC的类时，只需要在上面桥接头文件import即可</li><li>在OC中调用Swift类，则需在OC文件中import “项目名称-Swift.h” 头文件即可</li></ol></blockquote><h2 id="混合开发的问题"><a href="#混合开发的问题" class="headerlink" title="混合开发的问题"></a>混合开发的问题</h2><blockquote><p>最近有个新闻列表改版需求，那在此下使用Swift去重做这块需求，需求中遇到一些坑和大家分享下。</p></blockquote><ul><li>数模转换的坑<blockquote><p> 在OC项目中常用的MJExtension第三方库。那在swift中我们怎么做呢？<br>当然可以使用目前第三方库SwiftJson或者HandyJSON或者实现Codable协议。不过这里我使用的是系统KVC方式,遇到问题如下</p><ol><li>因为swift的构造函数与OC不一样，当子类中有自己的构造函数时，那么将不继承父类自定义的构造函数。所以子类需重写父类init(dict : [String : Any])这个构造函数否则将无法使用。</li><li>因为使用的是NSObject的KVC特性所以需加@objc定义子类属性。注意在swift4.0之前默认只要继承NSObject就会系统默认添加，但这之后需要手动添加了。</li></ol></blockquote></li></ul><pre><code>class BaseModel: NSObject {    override init() {    }    init(dict : [String : Any]) {        super.init()        setValuesForKeys(dict)    }    //记得重写该方法避免崩溃    override func setValue(_ value: Any?, forUndefinedKey key: String) {}}class NewsNavModel: BaseModel {    //type = 998 最新,999 收藏    @objc var type:Int = 0    @objc var type_name:String = &quot;&quot;    init(_ type : Int , type_name : String) {        super.init()        self.type = type        self.type_name = type_name    }    //需重写父类方法    override init!(dic: [String : Any]!) {        super.init(dic: dic)    }}</code></pre><ul><li><p>关于@objc坑</p><blockquote><ol><li>在swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在Swift4.0全都要加@objc修饰符</li><li>定义的方法，枚举，协议或者是属性如果需要被OC调用则需添加@objc</li><li>自定义的protocol协议中,有optional修饰的非必须实现的方法,需要用@objc修饰</li></ol></blockquote></li><li><p>被废弃的方法:</p><blockquote><p>initialize/dispatch_once方法已经被Swift4.0废弃所以后续不能再使用</p></blockquote></li><li><p>NSClassFromString方法的坑</p><blockquote><p>在OC的时候直接使用类名即可转换为对于Class，但是Swift中有命名空间存在所以使用这个方法需要添加项目的名称</p></blockquote></li></ul><pre><code>//OC 中Class ocClass = NSClassFromString(@&quot;MyFavModel&quot;);//Swift中let swiftClass = NSClassFromString(&quot;项目名称.MyFavModel&quot;) </code></pre><ul><li>fatalError<blockquote><p>在Swift 中继承了遵守NSCoding protocol的类时，并自定义构造函数时候则需加入required init(coder aDecoder: NSCoder)。这个是在OC中则不存在的。<br>其作用是表明子类不能通过被fatalError定义的函数做初始化</p></blockquote><pre><code>override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {  super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)  self.hidesBottomBarWhenPushed = true}</code></pre></li></ul><p>required init(coder aDecoder: NSCoder) {<br>    fatalError(“init(coder:) has not been implemented”)<br>}</p><pre><code>- OC的类不能继承至Swift的类，但是Swift类可以继承至OC的类。&gt; 补充：即使Swift的父类是OC也不能让OC类继承该Swift类- Swift中没有宏，只能使用全局常量或者全局函数替代。</code></pre><p>/// 当前app信息<br>let AppInfo = Bundle.main.infoDictionary</p><p>/// 当前app版本号<br>let AppCurrentVersion = Bundle.main.object(forInfoDictionaryKey: “CFBundleShortVersionString”) as! String</p><p>/// 日志打印<br>func DLog(str: String) {<br>    #if DEBUG<br>    print(“file: (#file), line:(#line),(str)”)<br>    #endif<br>}</p><pre><code>- Swift不像OC那样能直接调用C++,需通过OC或者C去调用C++。## 其他### Swift版本升级 &gt; 例如:Swift3.0 -&gt; Swift4.0&gt; 1. 选中要转换的 target&gt; 2. Edit -&gt; Convert -&gt; To Current Swift Syntax &gt; 3. 勾选需要转换的 target （pod 引用不用勾选），Next &gt; 4. 选择转换选项，Next ![](/images/2018/OC和Swift混编经验/1.png)### 快速的将OC语言转换成Swift语言&gt; 这里推荐一款swiftify插件。支持在线转换，或者添加插件到Xcode中。&gt; 1. [插件安装AppStore下载地址](https://itunes.apple.com/cn/app/swiftify-objective-c-converter-for-xcode/id1183412116?mt=12)&gt; 2. [在线转换地址](https://objectivec2swift.com/#/home)![](/images/2018/OC和Swift混编经验/2.png)### 快速将json转化为Swift的模型对象&gt; 基于Codable协议快速的数模序列化&gt; 1. 它不仅支持Swift,还支持其他语言比如Kotlin,Java,C#,Ruby,Object-c,Python&gt; 1. [在线链接](https://app.quicktype.io/)![](/images/2018/OC和Swift混编经验/3.png)### 通过R.swift快速生成资源代码根据项目内容来自动化生 ImageName 和 SegueName代码 可以使用Switf的自动化工具了，[R.swift](https://github.com/mac-cain13/R.swift) 和 [SwiftGen](https://github.com/SwiftGen/SwiftGen)</code></pre><p>let image = UIImage(imageName: .imgIcon)</p><pre><code>### Swift 测试速度- [Swift 与 Object-C的速度测试对比](https://www.jessesquires.com/blog/apples-to-apples-part-two/)- [Swift 与 C的速度测试对比](https://www.jessesquires.com/blog/apples-to-apples-part-three/)## 推荐&gt; Swift学习文档：&gt; 1. [The Swift Programming Language (Swift 4)](https://link.jianshu.com/?t=https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309)&gt; 2. [Swift的180个介绍](https://github.com/apple/swift-evolution/tree/master/proposals)&gt; Swift 书籍 &gt; 1. [Swifter - Swift 必备 tips](http://swifter.tips/buy)&gt; 2. [Swift 进阶](https://www.objccn.io/products/advanced-swift/)&gt; 参考地址&gt; 1. [Swift4.0新特性](https://www.cnblogs.com/baitongtong/p/7250940.html)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Swift简介&quot;&gt;&lt;a href=&quot;#Swift简介&quot; class=&quot;headerlink&quot; title=&quot;Swift简介&quot;&gt;&lt;/a&gt;Swift简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS怎么推送统计到达率</title>
    <link href="https://zhengzeqin.netlify.app/2018/07/04/iOS%E6%80%8E%E4%B9%88%E6%8E%A8%E9%80%81%E7%BB%9F%E8%AE%A1%E5%88%B0%E8%BE%BE%E7%8E%87/"/>
    <id>https://zhengzeqin.netlify.app/2018/07/04/iOS%E6%80%8E%E4%B9%88%E6%8E%A8%E9%80%81%E7%BB%9F%E8%AE%A1%E5%88%B0%E8%BE%BE%E7%8E%87/</id>
    <published>2018-07-04T19:03:02.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ios摘要"><a href="#ios摘要" class="headerlink" title="ios摘要"></a>ios摘要</h2><ul><li><a href="http://www.cocoachina.com/ios/20170126/18618.html" target="_blank" rel="noopener">iOS10里的通知与推送</a></li><li><a href="https://www.jianshu.com/p/ace1b422bad4" target="_blank" rel="noopener">国内 90%以上的 iOS 开发者，对 APNs 的认识都是错的</a><h2 id="体系图"><a href="#体系图" class="headerlink" title="体系图"></a>体系图</h2><img src="/images/2018/iOS%E6%80%8E%E4%B9%88%E6%8E%A8%E9%80%81%E7%BB%9F%E8%AE%A1%E5%88%B0%E8%BE%BE%E7%8E%87/1.png" alt="" loading="lazy"></li></ul><h2 id="直接进入正题如何统计到达"><a href="#直接进入正题如何统计到达" class="headerlink" title="直接进入正题如何统计到达"></a>直接进入正题如何统计到达</h2><h3 id="在iOS10中新增两个拓展"><a href="#在iOS10中新增两个拓展" class="headerlink" title="在iOS10中新增两个拓展"></a>在iOS10中新增两个拓展</h3><ol><li>其中的一个拓展UNNotificationServiceExtension 通知服务扩展</li></ol><ul><li>UNNotificationServiceExtension 是修改远程推送携带的内容。</li><li>UNNotificationServiceExtension 类 可以让开发者自定义推送展示的内容。你可以用 extension 修改推送内容和下载推送相关的资源。你可以在extension 中解密和加密的数据或下载推送相关的图片</li></ul><p>2.因此在这里可以提交到达的请求注意是这里处理时间只有30秒。为了不影响达到统计接口。一般会先发统计请求。同时通过缓存减少图片的请求。及图片的大小处理。</p><pre><code class="objc">@interface NotificationService ()&lt;NSURLSessionDelegate&gt;@property (nonatomic, strong) void (^contentHandler)(UNNotificationContent *contentToDeliver);@property (nonatomic, strong) UNMutableNotificationContent *bestAttemptContent;@end@implementation NotificationService- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler {    self.contentHandler = contentHandler;    self.bestAttemptContent = [request.content mutableCopy];    NSDictionary *userInfo = request.content.userInfo;    NSString *iconUrl = userInfo[[self fcmPushStrFromStr:@&quot;small_image&quot;]];//小图    NSString *imageUrl = userInfo[[self fcmPushStrFromStr:@&quot;image&quot;]];//大图    //重点这里发送给后端到达统计    [ProfessionTool sendFcmPushStatUserInfo:userInfo];//统计到达数    //这里是处理富文本图片 ，媒体视频等    UNNotificationAttachment *iconAtt = [self attachmentWithUrl:iconUrl fileName:@&quot;small_image&quot;];//待优化缓存方式    UNNotificationAttachment *imageAtt = [self attachmentWithUrl:imageUrl fileName:@&quot;image&quot;];    NSMutableArray *attArr = [NSMutableArray array];    if (iconAtt) [attArr addObject:iconAtt];    if (imageAtt) [attArr addObject:imageAtt];    self.bestAttemptContent.attachments = attArr;    self.contentHandler(self.bestAttemptContent);}- (UNNotificationAttachment *)attachmentWithUrl:(NSString *)url fileName:(NSString *)fileName{    if (url) {        UIImage *iconImg = [self getImageFromURL:url];        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);        NSString *documentsDirectoryPath = [paths firstObject];        NSString *iconPath = [self saveImage:iconImg withFileName:fileName ofType:@&quot;png&quot; inDirectory:documentsDirectoryPath];        if (iconPath &amp;&amp; ![iconPath isEqualToString:@&quot;&quot;]) {            UNNotificationAttachment * attachment = [UNNotificationAttachment attachmentWithIdentifier:fileName URL:[NSURL URLWithString:[@&quot;file://&quot; stringByAppendingString:iconPath]] options:nil error:nil];            if (attachment) {                return attachment;            }        }    }    return nil;}- (void)serviceExtensionTimeWillExpire {    // Called just before the extension will be terminated by the system.    // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used.    self.contentHandler(self.bestAttemptContent);}#pragma mark - private Method- (UIImage *)getImageFromURL:(NSString *)fileURL {    DLog(@&quot;执行图片下载函数&quot;);    UIImage * result;    //dataWithContentsOfURL方法需要https连接    NSData * data = [NSData dataWithContentsOfURL:[NSURL URLWithString:fileURL]];    result = [UIImage imageWithData:data];    return result;}//将所下载的图片保存到本地- (NSString *)saveImage:(UIImage *)image withFileName:(NSString *)imageName ofType:(NSString *)extension inDirectory:(NSString *)directoryPath {    NSString *urlStr = @&quot;&quot;;    if ([[extension lowercaseString] isEqualToString:@&quot;png&quot;]){        urlStr = [directoryPath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;%@.%@&quot;, imageName, @&quot;png&quot;]];        [UIImagePNGRepresentation(image) writeToFile:urlStr options:NSAtomicWrite error:nil];    } else if ([[extension lowercaseString] isEqualToString:@&quot;jpg&quot;] ||               [[extension lowercaseString] isEqualToString:@&quot;jpeg&quot;]){        urlStr = [directoryPath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;%@.%@&quot;, imageName, @&quot;jpg&quot;]];        [UIImageJPEGRepresentation(image, 1.0) writeToFile:urlStr options:NSAtomicWrite error:nil];    } else{        DLog(@&quot;extension error&quot;);    }    return urlStr;}//因项目中使用google 的FCM推送收到的推送字段有点不一样- (NSString *)fcmPushStrFromStr:(NSString *)str{    NSString *resultStr = str;    NSString *fcmPre = @&quot;gcm.notification.&quot;;    if (![resultStr containsString:fcmPre]) {        resultStr = [NSString stringWithFormat:@&quot;%@%@&quot;,fcmPre,resultStr];    }    return resultStr;}</code></pre><p>3.服务端配置内容需要添加”mutable-content”:1 （富文本推送）<br>很多人会搞混”content-available”:1（静默推送）</p><p>4.当然了google FCM的富文本推送是”mutable_content”:”true”<br>国内用的比较多的是激光JPush.百度推送等。后续会写篇google FCM 推送的配置方式</p><hr><pre><code>拿到的回调内容//iOS10 之前{&quot;aps&quot; : {    &quot;alert&quot; : &quot;title&quot;,    &quot;badge&quot; : 1,    &quot;sound&quot;:&quot;default&quot;        },}//iOS10 新增的文案多样性{&quot;aps&quot; : {    &quot;alert&quot; : {          &quot;title&quot; : &quot;title&quot;,          &quot;subtitle&quot; : &quot;subtitle&quot;,                  &quot;body&quot; : &quot;body&quot;                },    &quot;badge&quot; : 1,    &quot;sound&quot;:&quot;default&quot;        },}</code></pre><pre><code class="objc">//接收到推送回调函数//iOS1O之前的 //NS_AVAILABLE_IOS(3_0)- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo{    //最开始的接收推送回调}//NS_AVAILABLE_IOS(7_0)- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{    //这里亦可接收静默推送回调   }//iOS10之后统一 //  iOS10特性。App在前台获取通知- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification*)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler {   completionHandler(UNNotificationPresentationOptionAlert);}//点击通知进入App- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler {}</code></pre><p>5.与之前不同是ios10前台运行也能收到推送通知栏同样在上面userNotificationCenter接收处理点击事件</p><p>6.当然本人曾在低于iOS10版本通用过pod ‘JDStatusBarNotification’库模仿一个推送通知栏</p><p>7.测试发送iOS10的富文本推送低于iOS10版本的的用户只能收到title. subtitle内容是获取不到的。</p><p>8.Target的调试 将项目运行起来，然后发送一条推送之后，激活Service Extension，在XCode -DEBUG下Attach to Process 选择对于的target</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ios摘要&quot;&gt;&lt;a href=&quot;#ios摘要&quot; class=&quot;headerlink&quot; title=&quot;ios摘要&quot;&gt;&lt;/a&gt;ios摘要&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20170126/1861
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>UIWebView 替换成 WKWebView 与 JS 交互的兼容</title>
    <link href="https://zhengzeqin.netlify.app/2018/06/20/UIWebView-%E6%9B%BF%E6%8D%A2%E6%88%90-WKWebView-%E4%B8%8E-JS-%E4%BA%A4%E4%BA%92%E7%9A%84%E5%85%BC%E5%AE%B9/"/>
    <id>https://zhengzeqin.netlify.app/2018/06/20/UIWebView-%E6%9B%BF%E6%8D%A2%E6%88%90-WKWebView-%E4%B8%8E-JS-%E4%BA%A4%E4%BA%92%E7%9A%84%E5%85%BC%E5%AE%B9/</id>
    <published>2018-06-20T09:52:15.000Z</published>
    <updated>2020-08-25T02:36:34.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h2><pre><code>let postMessageToApp = (json) =&gt; {    if (!json) {        throw new Error(&#39;參數不正確&#39;)    }    try {        AppModel.jumpToApp(json) // UIWebview 的调用方式，老的        //分享 AppModel.share(json)    } catch (error) {        console.log(error)    }    try {        window.webkit.messageHandlers.AppModel.postMessage(json) // WKWebview 的调用方式，新的        //分享 window.webkit.messageHandlers.AppShareModel.postMessage(json)    } catch (error) {        console.log(error)    }}</code></pre><h2 id="交互代码"><a href="#交互代码" class="headerlink" title="交互代码"></a>交互代码</h2><pre><code>#import &lt;JavaScriptCore/JavaScriptCore.h&gt;#import &lt;WebKit/WebKit.h&gt;typedef void(^JumpToAppBlock)(NSDictionary *json);@protocol JavaScriptObjectiveCDelegate &lt;JSExport&gt;//分享- (void)share:(NSString *)json;//跳转- (void)jumpToApp:(NSString *)json;@end@interface TWWebAppJumpBaseModel:NSObject@property (nonatomic, weak) UIViewController *vc;@property (nonatomic, copy) JumpToAppBlock jumpToAppBlock;- (void)jumpToApp:(NSString *)json;- (void)share:(NSString *)json;@end@interface TWWebAppJumpModel : TWWebAppJumpBaseModel  &lt;JavaScriptObjectiveCDelegate&gt;@property (nonatomic, weak) JSContext *jsContext;@property (nonatomic, weak) UIWebView *webView;@end@interface TWWKWebJSBridgeModel:TWWebAppJumpBaseModel@property (nonatomic, weak) WKWebView *webView;- (void)setJSUserScriptNames:(NSArray *)userScriptNames;- (void)removeAllUserScripts;@end</code></pre><pre><code>#import &quot;TWWebAppJumpModel.h&quot;@implementation TWWebAppJumpBaseModel/** 跳轉 */- (void)jumpToApp:(NSString *)json{    //处理跳转    dispatch_async(dispatch_get_main_queue(), ^{    });}/** 分享 */- (void)share:(NSString *)json{    //处理分享    dispatch_async(dispatch_get_main_queue(), ^{    });}@end@implementation TWWebAppJumpModel@end@interface TWWKWebJSBridgeModel ()&lt;WKScriptMessageHandler&gt;@property (nonatomic, strong) NSArray *userScriptNames;@end@implementation TWWKWebJSBridgeModel/// 注入JS MessageHandler和Name- (void)setJSUserScriptNames:(NSArray *)userScriptNames{    if(_userScriptNames.count)[self removeAllUserScripts];    _userScriptNames = userScriptNames;    [userScriptNames enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {        [self.userContentController addScriptMessageHandler:self name:obj];    }];}/// 移除JS MessageHandler- (void)removeAllUserScripts{    [self.userScriptNames enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {        [self.userContentController removeScriptMessageHandlerForName:obj];    }];    self.userScriptNames = nil;}/// 接收JS调iOS的事件消息- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message{    DLog(@&quot;WK JS调iOS  name : %@    body : %@&quot;,message.name,message.body);    NSString *body = message.body;    if ([message.name isEqualToString:@&quot;AppModel&quot;]) {        if (IsStrClass(body)) {            [self jumpToApp:body];        }    }else if ([message.name isEqualToString:@&quot;AppShareModel&quot;]) {//分享        if (IsStrClass(body)) {            [self share:body];        }    }}@end</code></pre><h4 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h4><pre><code>- (TWWebAppJumpModel *)appModel{    if (!_appModel) {        _appModel = [[TWWebAppJumpModel alloc]init];        WS(weakSelf);        _appModel.jumpToAppBlock = ^(NSDictionary *json) {        };    }    return _appModel;}//设置jsContext- (void)webViewContext{    self.jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];    // 通过模型调用方法。    self.jsContext[@&quot;AppModel&quot;] = self.appModel;    self.appModel.jsContext = self.jsContext;    self.appModel.webView = self.webView;    self.appModel.vc = self;    self.jsContext.exceptionHandler = ^(JSContext *context, JSValue *exceptionValue) {        context.exception = exceptionValue;        DLog(@&quot;异常信息：%@&quot;, exceptionValue);    };}#pragma mark - UIWebViewDelegate- (void)webViewDidFinishLoad:(UIWebView *)webView{    [self webViewContext];}</code></pre><h4 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h4><pre><code>- (TWWKWebJSBridgeModel *)jsBridgeModel{    if (!_jsBridgeModel) {        _jsBridgeModel = [[TWWKWebJSBridgeModel alloc]init];        WS(weakSelf);        _jsBridgeModel.jumpToAppBlock = ^(NSDictionary *json) {        };    }    return _jsBridgeModel;}- (WKWebView *)createWKWebView{    //设置网页的配置文件    WKWebViewConfiguration * configuration = [[WKWebViewConfiguration alloc]init];    //允许视频播放    if (IOS_Versions &gt;= 9.0) {        configuration.allowsAirPlayForMediaPlayback = YES;        if ([self isUseWKCacheStore]) {            configuration.websiteDataStore = [WKWebsiteDataStore defaultDataStore];        }    }    configuration.preferences.javaScriptEnabled = YES;    configuration.preferences.javaScriptCanOpenWindowsAutomatically = NO;    // 允许在线播放    configuration.allowsInlineMediaPlayback = YES;    // 允许可以与网页交互，选择视图    configuration.selectionGranularity = YES;    // web内容处理池    configuration.processPool = [[WKProcessPool alloc] init];    configuration.suppressesIncrementalRendering = NO;    // 通过JS与webview内容交互    configuration.userContentController = [[WKUserContentController alloc] init];    self.jsBridgeModel.userContentController = configuration.userContentController;    self.jsBridgeModel.vc = self;    [self.jsBridgeModel setJSUserScriptNames:@[@&quot;AppModel&quot;,@&quot;AppShareModel&quot;]];    // 允许用户更改网页的设置    WKWebView *prewkwebview = [[WKWebView alloc] initWithFrame:CGRectZero configuration:configuration];    if (IOS_Versions &gt;= 9.0) {        NSString *agent = [USER_DEFAULTS objectForKey:@&quot;UserAgent&quot;];        if(![HouseValidateTool isEmpty:agent]){            prewkwebview.customUserAgent = agent;        }    }    prewkwebview.navigationDelegate = self;    prewkwebview.scrollView.delegate = self;    prewkwebview.UIDelegate = self;    self.jsBridgeModel.webView = prewkwebview;    return prewkwebview;}</code></pre><pre><code>- (void)dealloc{    [self.jsBridgeModel removeAllUserScripts];}</code></pre><pre><code>//在JS端调用alert函数时，会触发此代理方法。- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler;//JS端调用confirm函数时，会触发此方法- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler;//JS端调用prompt函数时，会触发此方法- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable result))completionHandler;</code></pre><h4 id="UIWebView-及-WKWebView执行js函数"><a href="#UIWebView-及-WKWebView执行js函数" class="headerlink" title="UIWebView 及 WKWebView执行js函数"></a>UIWebView 及 WKWebView执行js函数</h4><pre><code>//执行js 函数- (void)executejsContext:(NSString *)context{    WS(weakSelf);    if ([self isShowWKWebView]) {        dispatch_async(dispatch_get_main_queue(), ^{            [self.wkwebview evaluateJavaScript:context completionHandler:^(id _Nullable response, NSError * _Nullable error) {                DLog(@&quot;response: %@ error: %@&quot;, response, error);            }];        }）;    }else{         dispatch_async(dispatch_get_main_queue(), ^{            if (weakSelf.jsContext &amp;&amp; context) {                [weakSelf.jsContext evaluateScript:context];            }        });    }}</code></pre><ul><li>WKWebview的js与客户端交互回调函数didReceiveScriptMessage 是在主线程中</li><li>UIWebview的js与客户端的回调函数是实现JSExport协议的方法是在子线程中所以不是线程安全</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JS代码&quot;&gt;&lt;a href=&quot;#JS代码&quot; class=&quot;headerlink&quot; title=&quot;JS代码&quot;&gt;&lt;/a&gt;JS代码&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;let postMessageToApp = (json) =&amp;gt; {
    if (!json) {
      
    
    </summary>
    
    
    
      <category term="iOS" scheme="https://zhengzeqin.netlify.app/tags/iOS/"/>
    
  </entry>
  
</feed>
