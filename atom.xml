<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhengzeqin&#39;s blogs</title>
  <icon>https://www.gravatar.com/avatar/0a9ca8d6341cb336ce4e8dec91e975d8</icon>
  <subtitle>Lightly do not say gives up, otherwise sorry oneself</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vigilant-lovelace-ee6cb4.netlify.app/"/>
  <updated>2020-07-28T11:40:03.742Z</updated>
  <id>https://vigilant-lovelace-ee6cb4.netlify.app/</id>
  
  <author>
    <name>zhengzeqin</name>
    <email>zhengzeqin@addcn.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS开发老司机的神兵利器-效率工具</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2020/07/01/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2020/07/01/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/</id>
    <published>2020-07-01T11:03:09.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>作为<code>iOS</code>开发老司机们，我们肯定有各种各样的开发利器，以追求着<code>最高效率</code>。<br><br> 此篇分享下我们常用的各种<code>神兵利器</code>。如果有朋友能推荐更好的欢迎补充，分享我！<a href="https://juejin.im/post/5efadbcf6fb9a07eae53f126" target="_blank" rel="noopener">文章地址</a></p></blockquote><h2 id="Mac-常用的工具集"><a href="#Mac-常用的工具集" class="headerlink" title="Mac 常用的工具集"></a>Mac 常用的工具集</h2><h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a><a href="https://github.com/sirius1024/iterm2-with-oh-my-zsh" target="_blank" rel="noopener">iTerm2</a></h3><blockquote><ul><li><code>iTerm2 + Oh My Zsh</code> 打造舒适终端体验 </li><li>功能：支持个性主题，高亮插件，可选择、命令补全等</li><li>命令补全功能方便我日常命令输入，有点回到日常IDE开发的感觉！<br>效果图如下</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_iTerm2.png" alt=""></p><h3 id="ssh-工具-shuttle"><a href="#ssh-工具-shuttle" class="headerlink" title="ssh 工具 shuttle"></a><a href="https://github.com/fitztrev/shuttle" target="_blank" rel="noopener">ssh 工具 shuttle</a></h3><blockquote><p>方便我们将日常终端命令集成到 <code>shuttle</code> 中，方便快速执行命令</p><ul><li>工作中用它执行shh终端命令，远程链接屏幕，以及自动打包等构建命令</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_shuttle.jpg" alt=""></p><h3 id="uTools"><a href="#uTools" class="headerlink" title="uTools"></a><a href="https://www.u.tools/" target="_blank" rel="noopener">uTools</a></h3><blockquote><ul><li><code>uTools</code> 是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。</li><li>上面有方便开发人员使用各种各样的插件，比如解码编码器，json编码器，以及各种开发文档，对于 <code>flutter</code> 开发提供 <code>flutter pub search</code>，方便搜寻pub包<br>等</li><li>支持 <code>mac</code> , <code>windows</code> , <code>linux</code> 平台下载</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_uTools.png" alt=""></p><blockquote><p>快速启动</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_uTools2.png" alt=""></p><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a><a href="https://www.postman.com/" target="_blank" rel="noopener">Postman</a></h3><blockquote><p><code>Postman</code> 是一款功能强大的网页调试与发送网页HTTP请求的工具</p><ul><li>方便开发测试接口数据，它能够发送任何类型的HTTP 请求 (GET, HEAD, POST, PUT)，同时能保留历史请求数据</li><li>支持 <code>mac</code>,<code>windows</code>,<code>linux</code> 平台下载 以及Google浏览器插件安装</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Postman.png" alt=""></p><h3 id="MacDown"><a href="#MacDown" class="headerlink" title="MacDown"></a><a href="https://macdown.uranusjr.com/" target="_blank" rel="noopener">MacDown</a></h3><blockquote><ul><li>MacDown 是一款 Mac 下的开源 Markdown 编辑器。<a href="https://github.com/MacDownApp/macdown" target="_blank" rel="noopener">开源地址</a></li></ul></blockquote><blockquote><p>功能部分：</p><ul><li>高度可定制的 Markdown 渲染</li><li>支持代码块的语法着色</li><li>智能自动补全</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_MacDown.png" alt=""></p><h3 id="typora"><a href="#typora" class="headerlink" title="typora"></a><a href="https://www.typora.io/" target="_blank" rel="noopener">typora</a></h3><blockquote><ul><li><code>Typora</code> 也是一款支持实时预览的 Markdown 文本编辑器，是完全免费的。</li><li>支持 <code>mac</code>,<code>windows</code>,<code>linux</code> 平台下载</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_typora.png" alt=""></p><h2 id="推荐的网页在线工具"><a href="#推荐的网页在线工具" class="headerlink" title="推荐的网页在线工具"></a>推荐的网页在线工具</h2><h3 id="tinypng"><a href="#tinypng" class="headerlink" title="tinypng"></a><a href="https://tinypng.com/" target="_blank" rel="noopener">tinypng</a></h3><blockquote><p>在线图片压缩，支持 png,jpg</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_tinypng.png" alt=""></p><h3 id="processon"><a href="#processon" class="headerlink" title="processon"></a><a href="https://www.processon.com/" target="_blank" rel="noopener">processon</a></h3><blockquote><p>免费在线作图、实时协作<br>它可以在线画流程图、思维导图、UI 原型图、UML、网络拓扑图、组织结构图等等，<br>您无需担心下载和更新的问题，不管 Mac 还是 Windows ，一个浏览器就可以随时随地的发挥创意，规划工作</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_processon.png" alt=""></p><h2 id="iOS-开发工具集"><a href="#iOS-开发工具集" class="headerlink" title="iOS 开发工具集"></a>iOS 开发工具集</h2><h3 id="JSONConverter"><a href="#JSONConverter" class="headerlink" title="JSONConverter"></a><a href="https://github.com/iosyaowei/JSONConverter" target="_blank" rel="noopener">JSONConverter</a></h3><blockquote><ul><li><code>JSONConverter</code> 是MAC上iOS开发的辅助小工具，可以快速的把 json 数据转换生成对应的模型类属性，</li><li>目前支持<code>Objective-C</code>、<code>Swift</code>、<code>Flutter</code>以及目前流行的第三方库: <code>SwiftyJSON</code>、<code>HandyJSON</code>，<code>ObjectMapper</code>,可以灵活选择构建 <code>class/struct</code> ，并支持配置类名前缀等,省去手敲模型的麻烦，借此提高我们的开发效率。</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_JSONConverter.png" alt=""></p><h3 id="App-Icon-Gear"><a href="#App-Icon-Gear" class="headerlink" title="App Icon Gear"></a><a href="https://apps.apple.com/cn/app/app-icon-gear/id989646576?l=en&mt=12" target="_blank" rel="noopener">App Icon Gear</a></h3><blockquote><p><code>App Icon Gear</code> 图标切割神器，只需一张1024pt图片，非常方便我们一键导出所有尺寸的icon图</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_AppIconGear.png" alt=""></p><h3 id="Swiftify"><a href="#Swiftify" class="headerlink" title="Swiftify"></a><a href="https://swiftify.com/converter/home/" target="_blank" rel="noopener">Swiftify</a></h3><blockquote><ul><li><code>swiftify</code>插件。支持在线转换，或者添加插件到Xcode中,方便快速将Object-C代码转换为Swift</li><li><a href="https://itunes.apple.com/cn/app/swiftify-objective-c-converter-for-xcode/id1183412116?mt=12" target="_blank" rel="noopener">插件安装AppStore下载地址</a></li><li><a href="https://swiftify.com/converter/code/" target="_blank" rel="noopener">在线转换地址</a></li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Swiftify.png" alt=""></p><h3 id="quicktype"><a href="#quicktype" class="headerlink" title="quicktype"></a><a href="https://app.quicktype.io/" target="_blank" rel="noopener">quicktype</a></h3><blockquote><ul><li>快速将json转化为Swift的模型对象</li><li>基于Codable协议快速的数模序列化</li><li>它不仅支持Swift,还支持其他语言比如Kotlin,Java,C#,Ruby,Object-c,Python</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_quicktype.png" alt=""></p><h3 id="Lookin"><a href="#Lookin" class="headerlink" title="Lookin"></a><a href="https://lookin.work/" target="_blank" rel="noopener">Lookin</a></h3><blockquote><p><code>Lookin</code> 可以查看与修改 iOS App 里的 UI 对象，类似于 Xcode 自带的 UI Inspector 工具，或另一款叫做 Reveal 的软件。但借助于“控制台”和“方法监听”功能，Lookin 还可以进行 UI 之外的调试。<br>此外，虽然 Lookin 主体是一款 macOS 程序，它亦可嵌入你的 iOS App 而单独运行在 iPhone 或 iPad 上。最后，Lookin 完全免费。</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Lookin.png" alt=""></p><h3 id="Echo"><a href="#Echo" class="headerlink" title="Echo"></a><a href="https://github.com/didi/echo" target="_blank" rel="noopener">Echo</a></h3><blockquote><p><code>Echo</code>是一款客户端的桌面端调试工具，中文意思回声，寓意着Mac端和手机端之间就像回声一样相互联动。</p><ul><li>简单易用：将 Echo 和 App 连接到同一个局域网即可，无须额外配置。</li><li>功能齐全：目前已拥有网络请求、视图层级查看修改等10几个功能，覆盖了客户端研发的大部分场景。</li></ul></blockquote><blockquote><p>功能部分：</p><ul><li>高扩展性：插件和模块机制可以方便我们快速添加新功能。</li><li>基础功能：网络请求、NSUserDefaults 查看修改、日志查看、Crash 查看、GPS 模拟、通知查看</li><li>UI视图：视图层级查看修改、视图边框查看<br>性能检测：内存泄漏、卡顿检测</li><li>业务功能：基于插件能力可快速扩展你自己的业务插件能力</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Echo.png" alt=""></p><h3 id="SQLProSQLite"><a href="#SQLProSQLite" class="headerlink" title="SQLProSQLite"></a><a href="http://www.sqlitepro.com/" target="_blank" rel="noopener">SQLProSQLite</a></h3><blockquote><ul><li><code>SQLProSQLite</code>是一款优秀的数据库管理工具，不过要<code>付费</code> </li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_SQLProSQLite.png" alt=""></p><h3 id="BuildTimeAnalyzer"><a href="#BuildTimeAnalyzer" class="headerlink" title="BuildTimeAnalyzer"></a><a href="https://github.com/RobertGummesson/BuildTimeAnalyzer-for-Xcode" target="_blank" rel="noopener">BuildTimeAnalyzer</a></h3><blockquote><ul><li>项目中的 Swift 代码越写越多，发觉编译速度开始变慢。BuildTimeAnalyzer 工具可以检测项目中 Swift 的编译速度。</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_BuildTimeAnalyzer.png" alt=""></p><h3 id="Perfdog"><a href="#Perfdog" class="headerlink" title="Perfdog"></a><a href="https://perfdog.qq.com/" target="_blank" rel="noopener">Perfdog</a></h3><blockquote><ul><li>移动全平台 iOS/Android 性能测试、分析工具平台。快速定位分析性能问题，提升 APP 应用及游戏性能和品质。手机无需 ROOT/ 越狱，手机硬件、游戏及应用 APP 也无需做任何修改，极简化即插即用。</li><li>支持 <code>mac</code> , <code>windows</code>,平台下载</li></ul></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Perfdog.png" alt=""></p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a><a href="https://www.jenkins.io/" target="_blank" rel="noopener">Jenkins</a></h3><blockquote><ul><li><code>Jenkins</code>是开源 CI&amp;CD 软件领导者，提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。</li></ul></blockquote><blockquote><p>功能部分</p><ul><li>持续集成和持续交付</li><li>简易安装，配置简单</li><li>支持插件</li><li>扩展，分布式</li></ul></blockquote><blockquote><p>目前我们部门 <code>Jenkins</code> 平台已集成，自动化构建 <code>测试包</code> ，<code>AppStore包</code>，<code>图片压缩</code>，<code>OCLint</code> <code>SwiftLint</code> 语法检测，<code>组件自动构建</code>等，未来可期…</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Jenkins.png" alt=""></p><h2 id="日常用的工具集"><a href="#日常用的工具集" class="headerlink" title="日常用的工具集"></a>日常用的工具集</h2><blockquote><p>我的工具集全家桶</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_all.png" alt=""></p><h2 id="网友推荐篇"><a href="#网友推荐篇" class="headerlink" title="网友推荐篇"></a>网友推荐篇</h2><h3 id="KnuffApp"><a href="#KnuffApp" class="headerlink" title="KnuffApp"></a><a href="https://github.com/KnuffApp/Knuff" target="_blank" rel="noopener">KnuffApp</a></h3><blockquote><p>iOS 苹果推送测试工具, Mac OS 下的 apns 测试工具 ，类似的还有 <a href="https://github.com/shaojiankui/SmartPush" target="_blank" rel="noopener">SmartPush</a></p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_KnuffApp.jpg" alt=""></p><h3 id="Bagel"><a href="#Bagel" class="headerlink" title="Bagel"></a><a href="https://github.com/yagiz/Bagel" target="_blank" rel="noopener">Bagel</a></h3><blockquote><p><code>Bagel</code> 是一个小型的本地 iOS 网络调试器。它不是一个代理调试器，所以你不必纠结于证书、代理设置等。只要你的 iOS 设备和你的 Mac 在同一个网络中，你就可以查看由设备或模拟器分开的应用程序的网络流量。</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Bagel.png" alt=""></p><h3 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a><a href="https://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">Go2Shell</a></h3><blockquote><p><code>Go2Shell</code> 是一个可从Finder窗口在所需位置打开终端的工具。</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Go2Shell.png" alt=""></p><h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a><a href="https://www.alfredapp.com/" target="_blank" rel="noopener">Alfred</a></h3><blockquote><p><code>Alfred</code> 免费用户只能只能使用基本搜索和快速启动应用功能，若要使用Workflows，则需要购买Powerpack。</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Alfred.jpg" alt=""></p><h3 id="XSimulatorMngr"><a href="#XSimulatorMngr" class="headerlink" title="XSimulatorMngr"></a><a href="https://github.com/xndrs/XSimulatorMngr" target="_blank" rel="noopener">XSimulatorMngr</a></h3><blockquote><p><code>XSimulatorMngr</code> 快速查看iOS模拟器文件的工具,类似 <a href="https://simpholders.com/" target="_blank" rel="noopener">SimPholders</a></p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_XSimulatorMngr.png" alt=""></p><h3 id="Prepo"><a href="#Prepo" class="headerlink" title="Prepo"></a><a href="https://apps.apple.com/tw/app/prepo/id476533227?mt=12" target="_blank" rel="noopener">Prepo</a></h3><blockquote><p>Prepo 类似 <code>App Icon Gear</code> 一样只需1024pt图，导出需要icon</p></blockquote><p><img src="/images/2020/iOS%E5%BC%80%E5%8F%91%E8%80%81%E5%8F%B8%E6%9C%BA%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8-%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/iOS_tools_Prepo.png" alt=""></p><blockquote><p>…期待网友推荐待</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><p>重提下，此篇我们常用的各种<code>神兵利器</code>。如果有朋友能推荐更好的欢迎补充，分享给我,谢谢！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作为&lt;code&gt;iOS&lt;/code&gt;开发老司机们，我们肯定有各种各样的开发利器，以追求着&lt;code&gt;最高效率&lt;/c
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ios13苹果对UIWebView不再支持</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2020/05/13/ios13%E8%8B%B9%E6%9E%9C%E5%AF%B9UIWebView%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2020/05/13/ios13%E8%8B%B9%E6%9E%9C%E5%AF%B9UIWebView%E4%B8%8D%E5%86%8D%E6%94%AF%E6%8C%81/</id>
    <published>2020-05-13T11:03:04.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UIWebView-将被禁止提交审核"><a href="#UIWebView-将被禁止提交审核" class="headerlink" title="UIWebView 将被禁止提交审核"></a>UIWebView 将被禁止提交审核</h2><h3 id="在-iOS-13-推出后，如果开发者将包含-UIWebViewapi-的应用更新上传到-App-Store-审核后，其将会收到包含-ITMS-90809信息的回复邮件，提示你在下一次提交时将应用中-UIWebView的-api-移除。"><a href="#在-iOS-13-推出后，如果开发者将包含-UIWebViewapi-的应用更新上传到-App-Store-审核后，其将会收到包含-ITMS-90809信息的回复邮件，提示你在下一次提交时将应用中-UIWebView的-api-移除。" class="headerlink" title="在 iOS 13 推出后，如果开发者将包含 UIWebViewapi 的应用更新上传到 App Store 审核后，其将会收到包含 ITMS-90809信息的回复邮件，提示你在下一次提交时将应用中 UIWebView的 api 移除。"></a>在 iOS 13 推出后，如果开发者将包含 UIWebViewapi 的应用更新上传到 App Store 审核后，其将会收到包含 ITMS-90809信息的回复邮件，提示你在下一次提交时将应用中 UIWebView的 api 移除。</h3><blockquote><p>Dear Developer,<br>We identified one or more issues with a recent delivery for your app, “xxxxxxx. Your delivery was successful, but you may wish to correct the following issues in your next delivery:<br>ITMS-90809: Deprecated API Usage - Apple will no longer accept submissions of new apps that use UIWebView as of April 30, 2020 and app updates that use UIWebView as of December 2020. Instead, use WKWebView for improved security and reliability. Learn more (<a href="https://developer.apple.com/documentation/uikit/uiwebview" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uiwebview</a>).<br>After you’ve corrected the issues, you can upload a new binary to App Store Connect.<br>Best regards,<br>The App Store Team</p></blockquote><h3 id="项目用了一些第三库，比如WebViewJavascriptBridge-和-AFNetworking"><a href="#项目用了一些第三库，比如WebViewJavascriptBridge-和-AFNetworking" class="headerlink" title="项目用了一些第三库，比如WebViewJavascriptBridge 和 AFNetworking"></a>项目用了一些第三库，比如WebViewJavascriptBridge 和 AFNetworking</h3><ul><li>目前AFNetworking 已出4.0版本已移除UIWebView相关文件</li><li>假设我们不想手动删除文件或者更新最新库，可以通过Podfile配置移除涉及UIWebView相关的文件<blockquote><p>参考如下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">post_install do |installer|</span><br><span class="line">    dir_web &#x3D; File.join(installer.sandbox.pod_dir(&#39;WebViewJavascriptBridge&#39;), &#39;WebViewJavascriptBridge&#39;)</span><br><span class="line">    Dir.foreach(dir_web) &#123;|x|</span><br><span class="line">      real_path &#x3D; File.join(dir_web, x)</span><br><span class="line">      if (!File.directory?(real_path) &amp;&amp; File.exists?(real_path))</span><br><span class="line">        if(x &#x3D;&#x3D; &#39;WebViewJavascriptBridge.h&#39; || x &#x3D;&#x3D; &#39;WebViewJavascriptBridge.m&#39;)</span><br><span class="line">          File.delete(real_path)</span><br><span class="line">        end</span><br><span class="line">      end</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dir_web &#x3D; File.join(installer.sandbox.pod_dir(&#39;AFNetworking&#39;), &#39;UIKit+AFNetworking&#39;)</span><br><span class="line">    Dir.foreach(dir_web) &#123;|x|</span><br><span class="line">      real_path &#x3D; File.join(dir_web, x)</span><br><span class="line">      if (!File.directory?(real_path) &amp;&amp; File.exists?(real_path))</span><br><span class="line">        if(x &#x3D;&#x3D; &#39;UIWebView+AFNetworking.h&#39; || x &#x3D;&#x3D; &#39;UIWebView+AFNetworking.m&#39; || x &#x3D;&#x3D; &#39;UIKit+AFNetworking.h&#39;)</span><br><span class="line">          File.delete(real_path)</span><br><span class="line">        end</span><br><span class="line">      end</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;UIWebView-将被禁止提交审核&quot;&gt;&lt;a href=&quot;#UIWebView-将被禁止提交审核&quot; class=&quot;headerlink&quot; title=&quot;UIWebView 将被禁止提交审核&quot;&gt;&lt;/a&gt;UIWebView 将被禁止提交审核&lt;/h2&gt;&lt;h3 id=&quot;在
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins-fastlane自动构建</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2020/04/28/Jenkins-fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2020/04/28/Jenkins-fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/</id>
    <published>2020-04-28T11:03:02.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jenkins自动构建-去年基于Jenkins平台搭建的自动构建流程图"><a href="#Jenkins自动构建-去年基于Jenkins平台搭建的自动构建流程图" class="headerlink" title="Jenkins自动构建 去年基于Jenkins平台搭建的自动构建流程图"></a>Jenkins自动构建 去年基于Jenkins平台搭建的自动构建流程图</h1><p><img src="https://zeqinjie.github.io/images/2020/Jenkins+fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/1.png" alt=""></p><p><img src="https://zeqinjie.github.io/images/2020/Jenkins+fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/2.png" alt=""></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>Jenkins 作用及特点</li><li>怎么搭建Jenkins平台</li><li>Jenkins+fastlane的持续集成</li><li>怎么使用Jenkins触发自动打包构建</li><li>Jenkins构建遇到问题整理及解决</li><li>目前功能与未来的拓展</li></ul><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>Jenkins是开源CI&amp;CD软件领导者， 提供超过1000个插件来支持构建、部署、自动化， 满足任何项目的需要。</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>持续集成和持续交付</li><li>简易安装，配置简单</li><li>支持插件</li><li>扩展，分布式<h2 id="怎么搭建Jenkins平台"><a href="#怎么搭建Jenkins平台" class="headerlink" title="怎么搭建Jenkins平台"></a>怎么搭建Jenkins平台</h2></li><li>安装Java环境<ul><li>安装Java环境，目前jenkins只支持jdk8 </li></ul></li><li>安装 Jenkins<ul><li>先确保已安装Homebrew</li><li>命令安装 brew install jenkins</li><li>设置开机自启动</li></ul></li><li>启动 Jenkins <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li><li>安装插件<ul><li>Keychains and Provisioning Profiles - Management（管理本地的keychain和iOS证书的插件）</li><li>Xcode integration （用于xcode构建）</li></ul></li></ul><h2 id="Jenkins-fastlane持续集成"><a href="#Jenkins-fastlane持续集成" class="headerlink" title="Jenkins+fastlane持续集成"></a>Jenkins+fastlane持续集成</h2><ul><li>Fastlane是一整套的客户端CICD工具集合。Fastlane可以非常快速简单的搭建一个自动化发布服务，并且支持Android，iOS，MacOS。</li><li>Fastlane命令执行的底层并不是自己实现的，而是调用其他的插件或者工具执行的。比如说打包，Fastlane中的gym工具只是xcodebuild工具的一个封装，调用的其实还是xcodebuild中的打包命令。</li><li>Fastlane本身没有一套特殊语法，使用的Ruby语言。</li><li>Fastlane的插件工具叫做action，每一个action都对应一个具体的功能</li></ul><h2 id="目前功能与未来的拓展"><a href="#目前功能与未来的拓展" class="headerlink" title="目前功能与未来的拓展"></a>目前功能与未来的拓展</h2><ul><li>目前集成功能：<ul><li>测试包部署</li><li>线上包部署</li><li>静态图片压缩</li><li>OCLint语法检测</li></ul></li><li>未来优化点<ul><li>推送代码整合一套构建流程功能</li><li>简繁体转换集成</li><li>SwiftLint语法检测集成</li><li>…</li></ul></li></ul><p><img src="https://zeqinjie.github.io/images/2020/Jenkins+fastlane%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/3.png" alt=""></p><h3 id="具体配置待补充-未完待续"><a href="#具体配置待补充-未完待续" class="headerlink" title="具体配置待补充 , 未完待续.."></a>具体配置待补充 , 未完待续..</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jenkins自动构建-去年基于Jenkins平台搭建的自动构建流程图&quot;&gt;&lt;a href=&quot;#Jenkins自动构建-去年基于Jenkins平台搭建的自动构建流程图&quot; class=&quot;headerlink&quot; title=&quot;Jenkins自动构建 去年基于Jenkin
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>MVVM架构优势及应用场景</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2019/08/23/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2019/08/23/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2019-08-23T11:03:02.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RxSwift应用"><a href="#RxSwift应用" class="headerlink" title="RxSwift应用"></a>RxSwift应用</h1><h2 id="响应式编程-amp-amp-函数式编程"><a href="#响应式编程-amp-amp-函数式编程" class="headerlink" title="响应式编程 &amp;&amp; 函数式编程"></a>响应式编程 &amp;&amp; 函数式编程</h2><h3 id="什么是响应式编程？"><a href="#什么是响应式编程？" class="headerlink" title="什么是响应式编程？"></a>什么是响应式编程？</h3><blockquote><p>响应式编程，响应式编程是一种面向数据流和变化传播的编程方式式，简单理解就是异步的数据流的开发。</p></blockquote><h3 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h3><blockquote><p>特点是将函数作为一等公民，当作参数和返回值使用。典型的如OC和Swift 中的 map函数、filter函数、reduce函数等。每个函数的处理结果给到下一个函数，最后的结果由自身函数调出。</p></blockquote><hr><ul><li><a href="https://www.v2ex.com/amp/t/367308" target="_blank" rel="noopener">从入门到放弃</a><br><img src="https://zeqinjie.github.io/images/2019/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/1.png" alt=""><h2 id="为什么要使用-RxSwift-？"><a href="#为什么要使用-RxSwift-？" class="headerlink" title="为什么要使用 RxSwift ？"></a>为什么要使用 RxSwift ？</h2></li></ul><h3 id="我们先看一下-RxSwift-能够帮助我们做些什么："><a href="#我们先看一下-RxSwift-能够帮助我们做些什么：" class="headerlink" title="我们先看一下 RxSwift 能够帮助我们做些什么："></a>我们先看一下 RxSwift 能够帮助我们做些什么：</h3><h4 id="Target-Action"><a href="#Target-Action" class="headerlink" title="Target Action"></a>Target Action</h4><p>传统实现方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.addTarget(<span class="keyword">self</span>, action: #selector(buttonTapped), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buttonTapped</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"button Tapped"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Rx 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.rx.tap</span><br><span class="line">    .subscribe(onNext: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"button Tapped"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>你不需要使用 Target Action，这样使得代码逻辑清晰可见。</p><hr><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>传统实现方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        scrollView.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UIScrollViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"contentOffset: \(scrollView.contentOffset)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Rx 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        scrollView.rx.contentOffset</span><br><span class="line">            .subscribe(onNext: &#123; contentOffset <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"contentOffset: \(contentOffset)"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            .disposed(by: disposeBag)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你不需要书写代理的配置代码，就能获得想要的结果。</p><hr><h3 id="闭包回调"><a href="#闭包回调" class="headerlink" title="闭包回调"></a>闭包回调</h3><p>传统实现方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URLRequest</span>(url: url)) &#123;</span><br><span class="line">    (data, response, error) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> error == <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Data Task Error: \(error!)"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Data Task Error: unknown"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Data Task Success with count: \(data.count)"</span>)</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><p>通过 Rx 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLSession</span>.shared.rx.data(request: <span class="type">URLRequest</span>(url: url))</span><br><span class="line">    .subscribe(onNext: &#123; data <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Data Task Success with count: \(data.count)"</span>)</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Data Task Error: \(error)"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>回调也变得十分简单</p><hr><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>传统实现方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(updateNotificationStatus), </span><br><span class="line">                                                     name: <span class="type">UIApplication</span>.willEnterForegroundNotification,</span><br><span class="line">                                                   object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - Notification</span></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">updateNotificationStatus</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Application Will Enter Foreground"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Rx 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.rx.notification(<span class="type">UIApplication</span>.willEnterForegroundNotification)</span><br><span class="line">    .subscribe(onNext: &#123; (notification) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Application Will Enter Foreground"</span>)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你不需要去管理观察者的生命周期，这样你就有更多精力去关注业务逻辑。</p><hr><h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><p>传统实现方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> observerContext = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    user.addObserver(<span class="keyword">self</span>, forKeyPath: #keyPath(<span class="type">User</span>.name), options: [.new, .initial], context: &amp;observerContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> context == &amp;observerContext &#123;</span><br><span class="line">        <span class="keyword">let</span> newValue = change?[.newKey] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"do something with newValue"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    user.removeObserver(<span class="keyword">self</span>, forKeyPath: #keyPath(<span class="type">User</span>.name))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Rx 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    user.rx.observe(<span class="type">String</span>.<span class="keyword">self</span>, #keyPath(<span class="type">User</span>.name))</span><br><span class="line">        .subscribe(onNext: &#123; newValue <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"do something with newValue"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        .disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现 KVO 的代码更清晰，更简洁并且更准确。</p><hr><h4 id="多个任务之间有依赖关系"><a href="#多个任务之间有依赖关系" class="headerlink" title="多个任务之间有依赖关系"></a>多个任务之间有依赖关系</h4><p>例如，先通过用户名密码取得 Token 然后通过 Token 取得用户信息，</p><p>传统实现方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用回调的方式封装接口</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">API</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通过用户名密码取得一个 token</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">token</span><span class="params">(username: String, password: String,</span></span></span><br><span class="line"><span class="function"><span class="params">        success: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>,</span><br><span class="line">        failure: (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通过 token 取得用户信息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">userinfo</span><span class="params">(token: String,</span></span></span><br><span class="line"><span class="function"><span class="params">        success: <span class="params">(UserInfo)</span></span></span> -&gt; <span class="type">Void</span>,</span><br><span class="line">        failure: (<span class="type">Error</span>) -&gt; <span class="type">Void</span>) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 通过用户名和密码获取用户信息</span></span><br><span class="line"><span class="type">API</span>.token(username: <span class="string">"beeth0ven"</span>, password: <span class="string">"987654321"</span>,</span><br><span class="line">    success: &#123; token <span class="keyword">in</span></span><br><span class="line">        <span class="type">API</span>.userInfo(token: token,</span><br><span class="line">            success: &#123; userInfo <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"获取用户信息成功: \(userInfo)"</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            failure: &#123; error <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"获取用户信息失败: \(error)"</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    failure: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取用户信息失败: \(error)"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过 Rx 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用 Rx 封装接口</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">API</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通过用户名密码取得一个 token</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">token</span><span class="params">(username: String, password: String)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通过 token 取得用户信息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">userInfo</span><span class="params">(token: String)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">UserInfo</span>&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 通过用户名和密码获取用户信息</span></span><br><span class="line"><span class="type">API</span>.token(username: <span class="string">"beeth0ven"</span>, password: <span class="string">"987654321"</span>)</span><br><span class="line">    .flatMapLatest(<span class="type">API</span>.userInfo)</span><br><span class="line">    .subscribe(onNext: &#123; userInfo <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取用户信息成功: \(userInfo)"</span>)</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取用户信息失败: \(error)"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这样你无需嵌套太多层，从而使得代码易读，易维护。</p><hr><h4 id="等待多个并发任务完成后处理结果"><a href="#等待多个并发任务完成后处理结果" class="headerlink" title="等待多个并发任务完成后处理结果"></a>等待多个并发任务完成后处理结果</h4><p>例如，需要将两个网络请求合并成一个，</p><p>通过 Rx 来实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用 Rx 封装接口</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">API</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 取得老师的详细信息</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">teacher</span><span class="params">(teacherId: Int)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Teacher</span>&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 取得老师的评论</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">teacherComments</span><span class="params">(teacherId: Int)</span></span> -&gt; <span class="type">Observable</span>&lt;[<span class="type">Comment</span>]&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 同时取得老师信息和老师评论</span></span><br><span class="line"><span class="type">Observable</span>.<span class="built_in">zip</span>(</span><br><span class="line">      <span class="type">API</span>.teacher(teacherId: teacherId),</span><br><span class="line">      <span class="type">API</span>.teacherComments(teacherId: teacherId)</span><br><span class="line">    ).subscribe(onNext: &#123; (teacher, comments) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取老师信息成功: \(teacher)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取老师评论成功: \(comments.count) 条"</span>)</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"获取老师信息或评论失败: \(error)"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这样你可用寥寥几行代码来完成相当复杂的异步操作。</p><hr><h3 id="RxSwift-的单向数据流"><a href="#RxSwift-的单向数据流" class="headerlink" title="RxSwift 的单向数据流"></a>RxSwift 的单向数据流</h3><p>RxSwift 可以在 UniDirectional Data Flow 的各个阶段都发挥作用，从而让 Data 的处理和流动更加简洁和清晰。<br><img src="https://zeqinjie.github.io/images/2019/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/2.png" alt=""></p><ul><li>通过对 RxCocoa 的各种回调进行统一处理，方便了”交互”「Interact」的处理。</li><li>通过对 Observable 的 transform 和 composite，方便了 Action 的生成（比如使用 throttle 来压缩 Action）。</li><li>通过对网络请求以及其他异步数据的获取进行 Observable 封装，方便了异步数据的处理。</li><li>通过 RxCocoa 的 binding，方便了数据的渲染。</li></ul><h3 id="RxSwift优势"><a href="#RxSwift优势" class="headerlink" title="RxSwift优势"></a>RxSwift优势</h3><ul><li>组合 - Rx对不同的信号进行组合</li><li>复用 - 因为它是可组合的</li><li>清晰 - 因为声明都是不可变的，改变的只有数据</li><li>易用 - 因为它抽象的了异步编程，使我们统一了代码风格</li><li>内存回收 - 简单内存管理</li><li>稳定 - 因为 Rx 是完全通过单元测试的</li></ul><h2 id="RxSwift-与-MVVM的邂逅"><a href="#RxSwift-与-MVVM的邂逅" class="headerlink" title="RxSwift 与 MVVM的邂逅"></a>RxSwift 与 MVVM的邂逅</h2><blockquote><p>MVVM 是 Model-View-ViewModel 的缩写。</p></blockquote><ul><li>MVVM 增加了 ViewModel 层。我们可以将原来 Controller 中的业务逻辑抽取出来放到 ViewModel 中，从而大大减轻了 ViewController 的负担。</li><li>同时在 MVVM 中，ViewController 只担任 View 的角色（ViewController 与 View 现在共同作为 View 层），负责 View 的显示和更新，其他业务逻辑不再需要 ViewController 来管了。</li></ul><blockquote><p>同样使用 MVVM 架构时，Model 与 View|ViewControllter 之间是不允许直接通信的，而是由 ViewModel 层进行协调</p></blockquote><p><img src="https://zeqinjie.github.io/images/2019/MVVM%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/3.png" alt=""></p><h4 id="基于RxSwift对网络工具封装-TWSwiftHttpTool"><a href="#基于RxSwift对网络工具封装-TWSwiftHttpTool" class="headerlink" title="基于RxSwift对网络工具封装 TWSwiftHttpTool"></a>基于RxSwift对网络工具封装 TWSwiftHttpTool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明一个枚举，包含成功和失败的情况</span><br><span class="line">enum TWSwiftHttpResult &#123;</span><br><span class="line">    case success(Any)  &#x2F;&#x2F;成功</span><br><span class="line">    case failure(String) &#x2F;&#x2F;失败</span><br><span class="line">    case noNet() &#x2F;&#x2F;无网络</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 使用RxSwift进行扩展</span><br><span class="line">extension Reactive where Base: TWSwiftHttpTool &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 基于YYCache 缓存的RXSwift 请求方式</span><br><span class="line">    static func request(type: TWRequestType,</span><br><span class="line">                        url: String,</span><br><span class="line">                        parameters: [AnyHashable: Any]?,</span><br><span class="line">                        flag: Bool &#x3D; true,</span><br><span class="line">                        isCache: Bool &#x3D; false,</span><br><span class="line">                        cacheKey: String? &#x3D; nil,</span><br><span class="line">                        cacheBlock: (CacheBlock)? &#x3D; nil) -&gt; Observable&lt;Any&gt; &#123;</span><br><span class="line">        return Observable.create &#123; observer in</span><br><span class="line">            let task &#x3D; TWSwiftHttpTool.request(type: type, url: url, flag: flag, parameters: parameters, isCache: isCache, cacheKey: cacheKey, cacheBlock: cacheBlock, complete: &#123; (result) in</span><br><span class="line">                dealComplete(result: result, observer: observer)</span><br><span class="line">            &#125;)</span><br><span class="line">            return Disposables.create(with: task.cancel)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; MARK: - Private Common Method</span><br><span class="line">    private static func dealComplete(result:TWSwiftHttpResult,observer:AnyObserver&lt;Any&gt;) &#123;</span><br><span class="line">        switch result &#123;</span><br><span class="line">        case .success(let response):</span><br><span class="line">            observer.onNext(response)</span><br><span class="line">            observer.onCompleted()</span><br><span class="line">        case .failure(let reason):</span><br><span class="line">&#x2F;&#x2F;            observer.onNext([TWSwiftErrorMsg:reason])</span><br><span class="line">            observer.onError(RxNetworkError.general(reason))</span><br><span class="line">        case .noNet:</span><br><span class="line">&#x2F;&#x2F;            observer.onNext([TWSwiftErrorMsg:TWSwiftNoNetMsg])</span><br><span class="line">            observer.onError(RxNetworkError.noNet)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="viewModel-定义"><a href="#viewModel-定义" class="headerlink" title="viewModel 定义"></a>viewModel 定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;订阅输入输出协议</span><br><span class="line">protocol TWSwiftViewModelProtocol &#123;</span><br><span class="line">    associatedtype TWSwiftInput</span><br><span class="line">    associatedtype TWSwiftOutput</span><br><span class="line">    </span><br><span class="line">    func transform(input: TWSwiftInput) -&gt; TWSwiftOutput</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;viewModel实现TWSwiftViewModelProtocol的协议</span><br><span class="line">extension NewHouseWeekViewModel:TWSwiftViewModelProtocol&#123;</span><br><span class="line">    </span><br><span class="line">    typealias TWSwiftInput &#x3D; Input</span><br><span class="line">    </span><br><span class="line">    typealias TWSwiftOutput &#x3D; Output</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; MARK: - Override Method</span><br><span class="line">    struct Input &#123;</span><br><span class="line">        &#x2F;&#x2F;即是订阅又是被订阅</span><br><span class="line">        let requestId &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    struct Output &#123;</span><br><span class="line">        &#x2F;&#x2F;输出数据源</span><br><span class="line">        let sections: Driver&lt;[NewHouseWeekSectionModel]&gt;</span><br><span class="line">        &#x2F;&#x2F;成功输出</span><br><span class="line">        let successSubject &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line">        &#x2F;&#x2F;错误输出</span><br><span class="line">        let errorSubject &#x3D; PublishSubject&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">        init(sections: Driver&lt;[NewHouseWeekSectionModel]&gt;) &#123;</span><br><span class="line">            self.sections &#x3D; sections</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func transform(input: NewHouseWeekViewModel.Input) -&gt; NewHouseWeekViewModel.Output &#123;</span><br></pre></td></tr></table></figure><pre><code>}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### viewController通过viewModel实现model与view绑定</span><br></pre></td></tr></table></figure><p>/// viewModel绑定<br>    fileprivate func bindViewModel() {<br>        let vmInput = NewHouseWeekViewModel.Input() ///输入<br>        let vmOutput = viewModel.transform(input: vmInput) ///输出<br>        ///数据源绑定到tableview中<br>        vmOutput.sections.asDriver().drive(tableView.rx.items(dataSource: dataSource)).disposed(by: TWSwiftDisposeBag)<br>        ///错误订阅<br>        vmOutput.errorSubject.subscribe(onNext:{[weak self] (errorMsg) in<br>            self?.hideHud(in: self?.tableView, hint: errorMsg)<br>            self?.setEmptyDic()<br>        }).disposed(by: TWSwiftDisposeBag)<br>        ///成功订阅<br>        vmOutput.successSubject.subscribe(onNext: nil, onError: nil, onCompleted: {[weak self] in<br>            self?.hideHUD()<br>            self?.setEmptyDic()<br>        }, onDisposed: nil).disposed(by: TWSwiftDisposeBag)<br>        let regionId = TWSwiftGuardNullString(GlobalObject.share()?.regionId)<br>        ///发起数据请求<br>        vmInput.requestId.onNext(regionId)<br>        self.showActivityIndicatorSuperView(tableView)<br>    }</p><pre><code>### RxSwift的看法&gt; 理解响应链的编程思路&gt; RxSwift给我们带来最大影响的Reactive思想，OOP告诉我们，在编写应用程序的时候，要考虑的是对象有什么，对象做什么，对象与对象之间的联系，而Reactive思想将对象所做的都看成是数据流，我们关注的是事件本身的影响。## 参考链接- [RxSwift 使用详解系列](https://www.jianshu.com/p/f61a5a988590)- [RxSwift中文文档](https://beeth0ven.github.io/RxSwift-Chinese-Documentation/)- [是时候学习 RxSwift 了](https://limboy.me/tech/2016/12/11/time-to-learn-rxswift.html)- [RxSwift的整理](http://note.youdao.com/noteshare?id=ad1212ce231507cb934fd08dcc673d30)- [RxSwift github](https://github.com/ReactiveX/RxSwift)- [项目框架](http://bookmobile.debug.591.com.tw/)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RxSwift应用&quot;&gt;&lt;a href=&quot;#RxSwift应用&quot; class=&quot;headerlink&quot; title=&quot;RxSwift应用&quot;&gt;&lt;/a&gt;RxSwift应用&lt;/h1&gt;&lt;h2 id=&quot;响应式编程-amp-amp-函数式编程&quot;&gt;&lt;a href=&quot;#响应式编程-
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>基于Jenkins-Gitlab-蒲公英-附上shell脚本</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2019/04/11/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2019/04/11/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/</id>
    <published>2019-04-11T11:03:00.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jenkins-持续集成"><a href="#Jenkins-持续集成" class="headerlink" title="Jenkins 持续集成"></a>Jenkins 持续集成</h1><h2 id="自动化打包分发"><a href="#自动化打包分发" class="headerlink" title="自动化打包分发"></a>自动化打包分发</h2><blockquote><p>基于Jenkins + Gitlab + 蒲公英</p></blockquote><h3 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h3><h4 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h4><ol><li>安装Java环境，目前jenkins只支持jdk8 <a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">下载地址</a><blockquote><ol><li>安装完使用命令 java -version检查当前版本</li><li>java选择如图</li></ol></blockquote></li></ol><p><img src="https://zeqinjie.github.io/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/1.png" alt=""></p><ol start="2"><li>安装 Jenkins</li></ol><ul><li><p>先确保已安装<a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew</a> </p></li><li><p>命令安装 brew install jenkins</p></li><li><p>设置开机自启动</p><ul><li><p>创建一个链接到开机启动文件夹里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sfv &#x2F;usr&#x2F;local&#x2F;opt&#x2F;jenkins&#x2F;*.plist ~&#x2F;Library&#x2F;LaunchAgents</span><br></pre></td></tr></table></figure></li><li><p>手动启动jenkins </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl load ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure></li><li><p>手动关闭jenkins</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl unload ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="3"><li>启动 Jenkins<blockquote><p>浏览器打开连接</p></blockquote></li></ol><ul><li><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li></ul><ol start="4"><li>按照提示，找到/Users/wsh/.jenkins/secrets/initialAdminPassword 这个目录下的initialAdminPassword文件</li><li>Install suggested plugins 安装推荐插件</li><li>安装GitLab Plugin 和 Gitlab Hook Plugin</li></ol><h4 id="配置shell脚本"><a href="#配置shell脚本" class="headerlink" title="配置shell脚本"></a>配置shell脚本</h4><blockquote><p>注意 将shell脚本保存到工程目录下  保存为 zzq.sh</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">SECONDS&#x3D;0</span><br><span class="line"></span><br><span class="line">#默认使用的语言是英文</span><br><span class="line">export LANG&#x3D;zh_CN.UTF-8</span><br><span class="line">export LC_ALL&#x3D;zh_CN.UTF-8</span><br><span class="line"></span><br><span class="line">#假设脚本放置在与项目相同的路径下</span><br><span class="line">project_dir&#x3D;$(pwd)</span><br><span class="line"></span><br><span class="line">#编辑上传的文件全部放于此路径下,不影响原工程 ，保存项目目录地址</span><br><span class="line">upload_dir&#x3D;&quot;&#x2F;Users&#x2F;addcn&#x2F;Documents&#x2F;591TestAndUpload&quot;</span><br><span class="line"></span><br><span class="line">if [ -d &quot;$upload_dir&quot; ]; then</span><br><span class="line">    echo &quot;编辑上传的文件输出文件目录存在,目录为:$upload_dir&quot; </span><br><span class="line">else </span><br><span class="line">    echo &quot;编辑上传的文件目录不存在&quot; </span><br><span class="line">    mkdir -pv $upload_dir</span><br><span class="line">    echo &quot;创建打包文件目录$&#123;upload_dir&#125;成功&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#打包配置环境</span><br><span class="line">configuration&#x3D;&quot;Release&quot;</span><br><span class="line"></span><br><span class="line">#判断是用的xcodeproj还是直接xcworkspace，xcworkspace设置为true，否则设置为false</span><br><span class="line">isWorkSpace&#x3D;true</span><br><span class="line"></span><br><span class="line">#项目名称</span><br><span class="line">scheme&#x3D;&#96;find . -name *.xcodeproj | awk -F &quot;[&#x2F;.]&quot; &#39;&#123;print $(NF-1)&#125;&#39;&#96;</span><br><span class="line"></span><br><span class="line">projectName&#x3D;&quot;$&#123;scheme&#125;.xcworkspace&quot;</span><br><span class="line"></span><br><span class="line">#确定工程名称，如果用了cocopods，则使用xcworkspace，但是没有该文件则使用xcodeproj进行</span><br><span class="line"></span><br><span class="line">if [ -a &quot;$project_dir&#x2F;$projectName&quot; ]; then</span><br><span class="line">isWorkSpace&#x3D;true</span><br><span class="line">projectName&#x3D;&quot;$&#123;scheme&#125;.xcworkspace&quot;</span><br><span class="line">else</span><br><span class="line">isWorkSpace&#x3D;false</span><br><span class="line">projectName&#x3D;&quot;$&#123;scheme&#125;.xcodeproj&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#指定项目地址</span><br><span class="line">project_path&#x3D;&quot;$project_dir&#x2F;$projectName&quot;</span><br><span class="line"></span><br><span class="line">#确认输出日期</span><br><span class="line">buildDate&#x3D;$(date +%Y%m%d%H%M%S)</span><br><span class="line"></span><br><span class="line">#指定输出路径</span><br><span class="line">output_path&#x3D;&quot;$upload_dir&#x2F;package$buildDate&quot;</span><br><span class="line"></span><br><span class="line">#指定输出归档文件地址</span><br><span class="line">archive_path&#x3D;&quot;$output_path&#x2F;$&#123;scheme&#125;.xcarchive&quot;</span><br><span class="line"></span><br><span class="line">#指定输出ipa名称</span><br><span class="line">ipa_name&#x3D;&quot;$&#123;scheme&#125;.ipa&quot;</span><br><span class="line"></span><br><span class="line">#指定输出ipa地址</span><br><span class="line">ipa_path&#x3D;&quot;$output_path&#x2F;$ipa_name&quot;</span><br><span class="line"></span><br><span class="line">#指定xarchive文件导出授权样式 bundle id</span><br><span class="line">provisioningProfileName&#x3D;&quot;XC iOS: com.xxxx.xxxxxxx&quot;</span><br><span class="line"></span><br><span class="line">#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数</span><br><span class="line">export_method&#x3D;&#39;ad-hoc&#39;</span><br><span class="line"></span><br><span class="line">###############获取版本号,bundleID</span><br><span class="line">infoPlist&#x3D;&quot;$project_dir&#x2F;$scheme-Info.plist&quot;</span><br><span class="line">bundleVersion&#x3D;&#96;&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; $infoPlist&#96;</span><br><span class="line">bundleIdentifier&#x3D;&#96;&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Print CFBundleIdentifier&quot; $infoPlist&#96;</span><br><span class="line">bundleBuildVersion&#x3D;&#96;&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Print CFBundleVersion&quot; $infoPlist&#96;</span><br><span class="line">displayname&#x3D;&#96;&#x2F;usr&#x2F;libexec&#x2F;PlistBuddy -c &quot;Print CFBundleDisplayName&quot; $infoPlist&#96;</span><br><span class="line"></span><br><span class="line">#输出设定的变量值</span><br><span class="line">echo  &quot;项目名:$projectName&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;项目路径: $&#123;project_path&#125;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;打包xarchive文件路径: $&#123;archive_path&#125;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;打包ipa文件路径: $&#123;ipa_path&#125;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~开始编译~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line"></span><br><span class="line">#处理没有输出打包文件目录的情况</span><br><span class="line">if [ -d &quot;$output_path&quot; ]; then</span><br><span class="line">    echo &quot;打包文件输出文件目录存在,目录为:$output_path&quot; </span><br><span class="line">else </span><br><span class="line">    echo &quot;打包文件目录不存在&quot; </span><br><span class="line">    mkdir -pv $output_path</span><br><span class="line">    echo &quot;创建打包文件目录$&#123;output_path&#125;成功&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#处理编译文件目录的情况</span><br><span class="line">cd $upload_dir</span><br><span class="line">rm -rf .&#x2F;build</span><br><span class="line">buildAppToDir&#x3D;&quot;$upload_dir&#x2F;build&quot; #编译打包完成后.app文件存放的目录</span><br><span class="line"></span><br><span class="line">#重新进入当前项目路径下</span><br><span class="line">cd $project_dir</span><br><span class="line"></span><br><span class="line">security unlock-keychain -p &quot;addcn&quot; &#x2F;Users&#x2F;addcn&#x2F;Library&#x2F;Keychains&#x2F;login.keychain</span><br><span class="line"></span><br><span class="line">#开始编译app</span><br><span class="line">if $isWorkSpace ; then  #判断编译方式</span><br><span class="line">    echo  &quot;开始编译workspace....&quot; </span><br><span class="line">    xcodebuild  -workspace $projectName -scheme $scheme  -configuration $configuration clean build SYMROOT&#x3D;$buildAppToDir</span><br><span class="line">else</span><br><span class="line">    echo  &quot;开始编译target....&quot;</span><br><span class="line">    xcodebuild  -target  $projectName  -configuration $configuration clean build SYMROOT&#x3D;$buildAppToDir</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#判断编译结果</span><br><span class="line">if test $? -eq 0</span><br><span class="line">then</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~编译成功~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~编译失败~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;开始打包$scheme.app成$scheme.ipa.....&quot;</span><br><span class="line">cd $upload_dir</span><br><span class="line">findFolderName&#x3D;&#96;find . -name &quot;$configuration-*&quot; -type d |xargs basename&#96; #查找目录</span><br><span class="line">appDir&#x3D;$buildAppToDir&#x2F;$findFolderName  #app所在路径</span><br><span class="line"></span><br><span class="line">#重新进入当前项目路径下</span><br><span class="line">cd $project_dir</span><br><span class="line"></span><br><span class="line">echo &quot;打包xarchive文件,路径为:$archive_path&quot;</span><br><span class="line">if $isWorkSpace ; then  #判断编译方式</span><br><span class="line">    echo  &quot;开始打包workspace....&quot; </span><br><span class="line">    xcodebuild -workspace $projectName -scheme $scheme -destination generic&#x2F;platform&#x3D;iOS archive -configuration $&#123;configuration&#125; ONLY_ACTIVE_ARCH&#x3D;NO -archivePath $archive_path</span><br><span class="line">else</span><br><span class="line">    echo  &quot;开始打包target....&quot;</span><br><span class="line">    xcodebuild -target $projectName -scheme $scheme -destination generic&#x2F;platform&#x3D;iOS archive -configuration $&#123;configuration&#125; ONLY_ACTIVE_ARCH&#x3D;NO -archivePath $archive_path</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#检查文件是否存在</span><br><span class="line">if [ -a &quot;$archive_path&quot; ]; then</span><br><span class="line">echo &quot;打包$scheme.xcarchive成功.&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;打包$scheme.xcarchive失败.&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># echo &quot;开始导出$scheme.xcarchive成$scheme.ipa.....&quot;</span><br><span class="line"># xcodebuild -exportArchive -exportFormat ipa -archivePath $archive_path -exportPath $appDir&#x2F;$ipa_name -exportProvisioningProfile $provisioningProfileName</span><br><span class="line"></span><br><span class="line">echo &quot;开始打包$scheme.app成$scheme.ipa.....&quot;</span><br><span class="line">xcrun -sdk iphoneos PackageApplication -v $appDir&#x2F;$scheme.app -o $appDir&#x2F;$ipa_name #将app打包成ipa</span><br><span class="line"></span><br><span class="line">echo &quot;检查打包文件$appDir&#x2F;$&#123;ipa_name&#125;是否存在&quot;</span><br><span class="line">if [ -f &quot;$appDir&#x2F;$ipa_name&quot; ];then</span><br><span class="line">echo &quot;打包$&#123;ipa_name&#125;成功.&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;打包$&#123;ipa_name&#125;失败.&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cp -f -p $appDir&#x2F;$ipa_name $ipa_path   #拷贝ipa文件</span><br><span class="line">echo &quot;复制$&#123;ipa_name&#125;到$&#123;ipa_path&#125;成功&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &quot;~~~~~~~~~~~~~~~~~~~结束打包，处理成功~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">#输出总用时</span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;Finished.编译加打包共花费时间: $&#123;SECONDS&#125;s&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">echo &quot;正在上传至蒲公英平台&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;版本:$&#123;bundleVersion&#125;&quot;</span><br><span class="line"></span><br><span class="line">#蒲公英的ukey apikey</span><br><span class="line">curl -F &quot;file&#x3D;@$&#123;ipa_path&#125;&quot; -F &quot;uKey&#x3D;xxxxxxxxxxxxx&quot; -F &quot;_api_key&#x3D;xxxxxxxxxxxxxxx&quot; https:&#x2F;&#x2F;www.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload &gt; $output_path&#x2F;code.text</span><br><span class="line"></span><br><span class="line">result&#x3D;&#96;cat $output_path&#x2F;code.text&#96;</span><br><span class="line"></span><br><span class="line">result1&#x3D;&#96;echo &quot;$&#123;result##*&quot;appQRCodeURL&quot;&#125;&quot;&#96;</span><br><span class="line"></span><br><span class="line">length&#x3D;&#96;expr $&#123;#result1&#125; - 6&#96;</span><br><span class="line"></span><br><span class="line">result2&#x3D;&#96;echo $&#123;result1:3:$length&#125;&#96;</span><br><span class="line"></span><br><span class="line">result3&#x3D;&#96;echo $result2 | sed &#39;s:\\\&#x2F;:\&#x2F;:g&#39;&#96;</span><br><span class="line"></span><br><span class="line">if [ ! $result3 ];</span><br><span class="line">then</span><br><span class="line">   echo &quot;~~~~~~~~~~~~~~~~~~~上传失败~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;~~~~~~~~~~~~~~~~~~~上传成功~~~~~~~~~~~~~~~~~~~&quot;</span><br><span class="line">   echo &quot;生成的二维码链接为:$&#123;result3&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># echo &quot;删除编译文件包和打包&quot;</span><br><span class="line"># rm -rf $buildAppToDir</span><br><span class="line"># rm -rf $output_path</span><br><span class="line"></span><br><span class="line">#输出总用时</span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;Finished.共花费时间: $&#123;SECONDS&#125;s&#x3D;&#x3D;&#x3D;&quot;</span><br></pre></td></tr></table></figure><h4 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h4><ol><li>构建任务<ol><li>选择新建任务</li><li>如建远程develop。保存名称为remove_develop 项目</li></ol></li></ol><p><img src="https://zeqinjie.github.io/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/2.png" alt=""></p><ol start="2"><li>配置任务-源码管理</li></ol><p><img src="https://zeqinjie.github.io/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/3.png" alt=""></p><ol start="3"><li>配置任务 - 定时触发器配置(可选)<a href="https://www.jianshu.com/p/509c59391b3b" target="_blank" rel="noopener">参考</a></li></ol><p><img src="https://zeqinjie.github.io/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/4.png" alt=""></p><ol start="4"><li>配置任务 - 构建执行shell脚本命令</li></ol><p><img src="https://zeqinjie.github.io/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/5.png" alt=""></p><h4 id="Jenkins配置结果"><a href="#Jenkins配置结果" class="headerlink" title="Jenkins配置结果"></a>Jenkins配置结果</h4><h5 id="项目任务建立-（本地dev-远程dev-远程master）"><a href="#项目任务建立-（本地dev-远程dev-远程master）" class="headerlink" title="项目任务建立 （本地dev 远程dev 远程master）"></a>项目任务建立 （本地dev 远程dev 远程master）</h5><p><img src="https://zeqinjie.github.io/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/6.png" alt=""></p><h5 id="执行构建"><a href="#执行构建" class="headerlink" title="执行构建"></a>执行构建</h5><p><img src="https://zeqinjie.github.io/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/7.png" alt=""></p><h5 id="执行历史"><a href="#执行历史" class="headerlink" title="执行历史"></a>执行历史</h5><p><img src="https://zeqinjie.github.io/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/8.png" alt=""></p><h4 id="蒲公英平台"><a href="#蒲公英平台" class="headerlink" title="蒲公英平台"></a>蒲公英平台</h4><p><img src="https://zeqinjie.github.io/images/2019/%E5%9F%BA%E4%BA%8EJenkins-Gitlab-%E8%92%B2%E5%85%AC%E8%8B%B1-%E9%99%84%E4%B8%8Ashell%E8%84%9A%E6%9C%AC/9.png" alt=""></p><h2 id="局域网ip-端口访问失败"><a href="#局域网ip-端口访问失败" class="headerlink" title="局域网ip + 端口访问失败"></a>局域网ip + 端口访问失败</h2><blockquote><p>修改 </p></blockquote><ul><li>homebrew.mxcl.jenkins.plist 的 httpListenAddress 为 0.0.0.0<blockquote><p>目录地址</p></blockquote></li><li>~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist<blockquote><p>重启</p></blockquote></li><li>brew services stop jenkins</li><li>brew services start jenkins</li></ul><h2 id="打包失败"><a href="#打包失败" class="headerlink" title="打包失败"></a>打包失败</h2><blockquote><p>如报异常:<br>xcrun: error: unable to find utility “PackageApplication”, not a developer tool or in PATH<br>则根据如下链接操作:</p><ol><li>Xcode脚本自动化打包问题：xcrun: error: unable to find utility “PackageApplication”, not a developer tool or in PATH</li><li>后面根据对比发现新版的Xcode少了这个PackageApplication（转注：PackageApplication在前几个版本已被标识为废弃，在8.3版本彻底移除了）<br>先去找个旧版的Xcode里面copy一份过来</li><li>放到下面这个目录：<br>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/</li><li>然后执行命令：</li></ol><ul><li>sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer/</li><li>chmod +x /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/PackageApplication</li></ul></blockquote><ul><li>附上PackageApplication下载地址：</li><li><a href="https://pan.baidu.com/s/1jHJF2Lo" target="_blank" rel="noopener">https://pan.baidu.com/s/1jHJF2Lo</a></li><li><a href="https://www.cnblogs.com/Crazy-ZY/p/7115076.html" target="_blank" rel="noopener">参考链接</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jenkins-持续集成&quot;&gt;&lt;a href=&quot;#Jenkins-持续集成&quot; class=&quot;headerlink&quot; title=&quot;Jenkins 持续集成&quot;&gt;&lt;/a&gt;Jenkins 持续集成&lt;/h1&gt;&lt;h2 id=&quot;自动化打包分发&quot;&gt;&lt;a href=&quot;#自动化打包分
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Firebase的使用集合（二）</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2018/12/06/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2018/12/06/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2018-12-06T11:03:02.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程配置"><a href="#远程配置" class="headerlink" title="远程配置"></a><a href="https://firebase.google.com/docs/remote-config/" target="_blank" rel="noopener">远程配置</a></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Firebase 远程配置是一项云端服务，可让您更改应用的行为和外观，而无需用户下载应用更新。使用远程配置时，您可以创建应用内默认值，用于控制应用的行为和外观。之后，您便可以使用 Firebase 控制台或 Remote Config REST API，使得应用的所有用户或细分用户群获得不同于默认值的行为和外观。您的应用可控制何时安装更新，并能经常检查有无更新并安装更新，且对性能的影响微乎其微。<a href="https://juejin.im/post/5c08df4c6fb9a04a0c2e3e07" target="_blank" rel="noopener">掘金地址</a></p></blockquote><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>将更改快速发布至应用的用户群<ul><li>您可以通过更改服务端参数值来更改应用的默认行为和外观。</li><li>例如，您可以更改应用的布局或颜色主题背景以配合季节性促销，而无需发布应用更新。</li></ul></li><li>针对细分用户群量身打造应用<ul><li>您可以使用远程配置为不同的细分用户群（按应用版本、按 Google Analytics for Firebase 受众群体、按语言及更多因素划分）提供多样化的应用用户体验。</li></ul></li><li>运行 A/B 测试以改进您的应用<ul><li>您可以结合使用远程配置随机百分位定位和 Google Analytics for Firebase，在不同的细分用户群中针对应用的改进之处进行 A/B 测试，以便能够先验证这些改进之处，然后再将其推向整个用户群。</li></ul></li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过Cocopod导入</span><br><span class="line">pod &#39;Firebase&#x2F;RemoteConfig&#39;，</span><br></pre></td></tr></table></figure><blockquote><p>与performance一样，默认会在[FIRApp configure]; 初始化 <br></p></blockquote><p>&lt;!–&gt; -FIRAnalyticsDebugDisabled–&gt;</p><!---FIRAnalyticsDebugEnabled--><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" alt=""></p><blockquote><p>Firebase   DebugView调试部分 <br><br>[√] FIRAnalyticsDebugDisabled : 调试关闭<br><br>[√] FIRAnalyticsDebugEnabled : 调试打开<br></p></blockquote><h4 id="创建参数及条件"><a href="#创建参数及条件" class="headerlink" title="创建参数及条件"></a>创建参数及条件</h4><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" alt=""></p><p>Parameters ：参数列表</p><ul><li>设定参数的指定条件</li><li>限制最多2000个参数</li></ul><p>Conditions ：条件列表</p><ul><li>Remote Config 提供多种条件选项，比如操作系统,语言，国家地区，目标对象…</li><li>限制最多 500个条件</li></ul><p>Parameters和Conditions的限制</p><ul><li>参数键最多可包含 256 个字符，且必须以下划线或英文字母（A-Z、a-z）开头，还可以包含数字。一个项目中所有参数值字符串的总长度不能超过 80 万个字符</li></ul><blockquote><p><a href="https://firebase.google.com/docs/remote-config/parameters" target="_blank" rel="noopener">我们配置app_color这个参数，支持json字符串</a><br><br> [[FIRRemoteConfig remoteConfig]configValueForKey:@”app_color”]</p></blockquote><h4 id="app获取远程配置好的数据"><a href="#app获取远程配置好的数据" class="headerlink" title="app获取远程配置好的数据"></a>app获取远程配置好的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)firebaseRemoteConfigure&#123;</span><br><span class="line">    &#x2F;&#x2F;过期时间。默认设置为60分钟</span><br><span class="line">    NSTimeInterval duration &#x3D; 3600;</span><br><span class="line">#if DEBUG</span><br><span class="line">    &#x2F;&#x2F;配置设置，是否打开调试模式</span><br><span class="line">    FIRRemoteConfigSettings *setting &#x3D; [[FIRRemoteConfigSettings alloc]initWithDeveloperModeEnabled:YES];</span><br><span class="line">    [FIRRemoteConfig remoteConfig].configSettings &#x3D; setting;</span><br><span class="line">    &#x2F;&#x2F;这边测试调试，所以设置为0分钟</span><br><span class="line">    duration &#x3D; 0;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;&#x2F; 设置60分钟触发更新  3600</span><br><span class="line">    [[FIRRemoteConfig remoteConfig] fetchWithExpirationDuration:duration completionHandler:^(FIRRemoteConfigFetchStatus status, NSError * _Nullable error) &#123;</span><br><span class="line">        if(!error)&#123;</span><br><span class="line">            DLog(@&quot;FIRRemoteConfigstatus &#x3D; %d&quot;,status);</span><br><span class="line">            BOOL activateFetched &#x3D; [[FIRRemoteConfig remoteConfig]activateFetched];</span><br><span class="line">            if (activateFetched) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取服务端的值</span><br><span class="line">                FIRRemoteConfigValue *value &#x3D; [[FIRRemoteConfig remoteConfig] configValueForKey:@&quot;app_color&quot;];</span><br><span class="line">                DLog(@&quot;FIRRemoteConfigvalue &#x3D; %@, %@&quot;,value.dataValue,value.stringValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>fetchWithExpirationDuration:completionHandler: 使用 (默认情况下，缓存在 12 小时后失效)<br><br>需限制是在 60 分钟的时间段内最多可以提取 5次。否则如果您的应用多次使用 fetchWithExpirationDuration:completionHandler: 请求刷新值，请求会遭到阻止，并向您的应用提供缓存的值。 <a href="https://firebase.google.com/docs/remote-config/ios?authuser=0#caching_and_throttling" target="_blank" rel="noopener">参考</a></li><li>使用远程配置模板时，请注意以下要求：这些模板有不同的版本，每个版本的有效期均为 90 天（从创建之日起到将其替换为更新版本为止），而存储的版本总数不超过 300 个</li></ul><h2 id="A-B-Test"><a href="#A-B-Test" class="headerlink" title="A/B Test"></a><a href="https://firebase.google.com/docs/ab-testing/" target="_blank" rel="noopener">A/B Test</a></h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Firebase A/B 测试可让您轻松地运行、分析和扩展产品和营销实验，从而帮助您改进应用。它使您能够测试应用界面、功能或互动广告系列的更改，以确认这些更改是否确实使关键指标（如收入和用户留存率）较更改前有所改观。</p></blockquote><h3 id="支持两种测试方式"><a href="#支持两种测试方式" class="headerlink" title="支持两种测试方式"></a>支持两种测试方式</h3><ul><li><a href="https://firebase.google.com/docs/ab-testing/abtest-config?authuser=0" target="_blank" rel="noopener">创建远程配置实验</a></li><li><a href="https://firebase.google.com/docs/ab-testing/abtest-with-console?authuser=0" target="_blank" rel="noopener">创建消息传递实验</a></li></ul><h3 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li>运行测试并提升您的产品使用体验<ul><li>通过远程配置创建实验，在实验的变体中更改应用的行为和外观，并测试哪种产品使用体验能最有效地带来您最关注的效果。</li></ul></li><li>使用通知编辑器寻找再次吸引用户的方法<ul><li>使用 A/B 测试帮助您找出最有效的措辞和消息设置来吸引用户使用您的应用。</li></ul></li><li>安全推出新功能<ul><li>要推出新功能，首先必须在一小部分用户身上进行测试，确保其符合您的目标。等到对 A/B 测试结果有了信心后，再面向全部用户推出功能。</li></ul></li><li>定位“预测”的用户群<ul><li>借助 Firebase 预测功能，您可以针对预计会执行特定操作的用户运行 A/B 测试，这类操作包括花钱消费（或不花钱）、停止使用您的应用，以及执行您通过 Analytics 定义的任何其他转化事件等。</li></ul></li></ul><h3 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过Cocopod导入</span><br><span class="line">pod &#39;FirebaseABTesting&#39;</span><br></pre></td></tr></table></figure><blockquote><p>默认会在[FIRApp configure]; 初始化 <br><br>通过远程配置方式获取参数数据代码参考RemoteConfig部分</p></blockquote><h4 id="创建A-B-TEST实验"><a href="#创建A-B-TEST实验" class="headerlink" title="创建A/B TEST实验"></a>创建A/B TEST实验</h4><blockquote><p>创建remote_a/b_test实例</p></blockquote><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" alt=""></p><blockquote><p>创建测试条件及参数</p></blockquote><ul><li>控制组，Variant A  两组数据</li></ul><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" alt=""></p><blockquote><p>测试配置执行的ID凭证</p></blockquote><ul><li>ID凭证即是fcmToken</li></ul><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" alt=""></p><blockquote><p>通过远程配置的方式获取到参数条件</p></blockquote><ul><li>参考Remote Configure 远程配置方式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;远程配置&quot;&gt;&lt;a href=&quot;#远程配置&quot; class=&quot;headerlink&quot; title=&quot;远程配置&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://firebase.google.com/docs/remote-config/&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>移动端性能标准值及定义整理</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2018/11/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%A7%E8%83%BD%E6%A0%87%E5%87%86%E5%80%BC%E5%8F%8A%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2018/11/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%A7%E8%83%BD%E6%A0%87%E5%87%86%E5%80%BC%E5%8F%8A%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86/</id>
    <published>2018-11-22T11:03:01.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>这个月Boss需要我们整理一份各个性能采集后的参考值，对于崩溃的数据采集，我们接入有Bugly,友盟。对于性能采集我们接入的是<a href="https://firebase.google.com/products/performance/" target="_blank" rel="noopener">Firebase Performace</a> </p></blockquote><h2 id="591的性能指标"><a href="#591的性能指标" class="headerlink" title="591的性能指标"></a>591的性能指标</h2><p><img src="https://zeqinjie.github.io/images/2018/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%80%A7%E8%83%BD%E6%A0%87%E5%87%86%E5%80%BC%E5%8F%8A%E5%AE%9A%E4%B9%89%E6%95%B4%E7%90%86/1.png" alt=""></p><h3 id="指标说明"><a href="#指标说明" class="headerlink" title="指标说明"></a>指标说明</h3><blockquote><p>日报使用：崩溃率（友盟最新版）、启动时间（Performance）<br><br>统计使用：崩溃率（友盟最新版）、用户崩溃率（友盟最新版）、ANR率/卡顿率（bugly最新版）、启动时间（Performance）、網路呼叫成功率（Performance）<br><br>崩溃率的定义：友盟比较符合大多数人的理解<br><br>参考值的定义：崩溃率和启动时间，虽然有找到一些参考值，不过对比之后显示我们的数据非常好（原因是平台统计数据为业内平均值），所以我们依据591近期的数据和自我要求，定义了一个参考值（如上日报）<br><br>其它：用户崩溃率、ANR率/卡顿率、網路呼叫成功率，对于App的性能评估也有一定的作用，不过日报里面建议先不添加，避免太多内容</p></blockquote><h2 id="App性能指标定义"><a href="#App性能指标定义" class="headerlink" title="App性能指标定义"></a>App性能指标定义</h2><table style="word-wrap:break-word;text-align:center">    <tr>        <td>平台</td>         <td> 名称</td>         <td >计算方式</td>         <td >描述</td>     </tr>    <tr>        <td rowspan="2" >友盟</td>            <td >崩溃率/错误率</td>          <td >崩溃次数/启动次数</td>        <td style="text-align:left">1.崩溃次数/错误次数：<br>该类错误在一定时间范围内产生的次数，也就是SDK上报的日志数量 <br> 2.启动次数:<br> 1).Android：启动是通过在所有activity中调用MobclickAgent.onResume() 和MobclickAgent.onPause()方法来监测的<br>2).iOS：进入后台即算是当前统计会话结束。当再次进入前台时，算作一次新的启动行为，<br>并开始新的统计会话</td>    </tr>    <tr>        <td >用户崩溃率</td>          <td >影响用户/活跃用户</td>         <td style="text-align:left">1.影响用户数：在一定时间范围内对该类错误的所有错误日志按照设备维度进行排重计数 <br> 2.活跃用户：所选时间段内，启动过应用的用户(去重)，启动过一次的用户即被视为活跃用户，包括新用户和老用户。</td>    </tr>    <tr>        <td rowspan="4">Bugly</td>            <td >次数崩溃率</td>          <td >发生次数/联网次数</td>         <td style="text-align:left">1.发生次数：一个异常发生且被记录上报，计为一次异常发生。<br>2.联网次数：即 启动次数+跨天联网次数。<br>3.跨天联网：用户没有启动应用，只有应用进程在后台运行，且超过零点，计为一次跨天联网。<br>4.启动次数：以下场景均计为一次启动<br>1).应用完全退出后重新启动，计为一次启动；<br>2).应用被切换至后台后，30秒后被切换至前台，计为一次启动，若未超过30秒切换至前台，不算一次启动。</td>     </tr>    <tr>        <td >用户崩溃率</td>          <td >影响用户/活跃用户</td>         <td style="text-align:left">1.影响用户数：在一定时间范围内对该类错误的所有错误日志按照设备维度进行排重计数 <br> 2.活跃用户：所选时间段内，启动过应用的用户(去重)，启动过一次的用户即被视为活跃用户，包括新用户和老用户。</td>    </tr>    <tr>        <td nowrap="nowrap">次数ANR率/卡顿率</td>          <td nowrap="nowrap">发生次数/联网次数</td>         <td >同上次数崩溃率描述</td>    </tr>    <tr>        <td >用户ANR率/卡顿率</td>          <td >影响用户/联网用户</td>         <td >同上用户崩溃率描述</td>    </tr>    <tr>        <td rowspan="2" nowrap="nowrap">Performace</td>            <td >启动时间</td>         <td >從程式碼初始化 - 使用者介面有所回應為止</td>        <td > <a href= "https://firebase.google.com/docs/perf-mon/automatic?authuser=0">定义</a><br>1.iOS:在应用将第一个 Object 加载到内存时开始，第一个 run loop 成功（应用收到 UIApplicationDidBecomeActiveNotification 通知后）时停止。<br>2.Android:在应用的 FirebasePerfProvider ContentProvider 完成其 onCreate 方法时开始，第一个 Activity 的 onResume() 方法被调用时停止。</td>    </tr>    <tr>        <td >網路呼叫成功率 </td>         <td >成功响应次数/总响应次数</td>        <td > 由傳回 2xx 或 3xx 回應代碼的應用程式提出的 HTTP/S 要求百分比。如需查看詳細資訊，請前往「網路要求」分頁</td>    </tr>        <tr>        <td rowspan="2" nowrap="nowrap">GooglePlay</td>            <td >當機率</td>         <td >无</td>        <td > 使用者遇到至少1次當機情形的每日工作階段百分比。每日工作階段是指使用者一天內使用應用程式的時間</td>    </tr>    <tr>        <td >ANR 发生率 </td>         <td >无</td>        <td > 使用者遇到至少 1 次 ANR 情形的每日工作階段百分比。每日工作階段是指使用者一天內使用應用程式的時間。</td>    </tr>    <tr>        <td nowrap="nowrap">App Store Connect </td>         <td >崩溃率</td>        <td > 崩溃次数/使用次数</td>        <td >目前appstore 统计是限参与统计用户<br>计算方式是 = 崩溃次数/使用次数 （使用次数:使用时间超过2s的次数）附:仅限参与统计用户</td>    </tr></table><h2 id="App性能指标业内参考值"><a href="#App性能指标业内参考值" class="headerlink" title="App性能指标业内参考值"></a>App性能指标业内参考值</h2><table style="text-align:center">    <tr >        <td rowspan="2">名称</td>          <td colspan="3">业内参考值</td>    </tr>    <tr>        <td>iOS</td>         <td>Android</td>         <td>数据来源</td>    </tr>    <tr>        <td rowspan="8">崩溃率</td>            <td >1.01%</td>          <td >0.2%</td>        <td >听云16年报告 - 年平均崩溃率</td>    </tr>    <tr>        <td>0.93%</td>         <td>0.13%</td>         <td >听云15年报告 - 年平均崩溃率</td>    </tr>    <tr>        <td>0.78%</td>         <td>1.89%</td>         <td >听云17年报告 - 房产中介 - 年平均崩溃率</td>    </tr>    <tr>        <td>0.79%</td>         <td>0.17%</td>         <td >听云17年报告 - 工具 - 年平均崩溃率</td>    </tr>    <tr>        <td>0.38%</td>         <td>0.09%</td>         <td >听云16年报告 - 软件工具 - 年平均崩溃率</td>    </tr>    <tr>        <td nowrap="nowrap">优秀值0.3%<br>标准值0.8%</td>         <td nowrap="nowrap">优秀值0.2%<br>标准值0.4%</td>         <td ><a href= "https://blog.csdn.net/x32sky/article/details/52778169">来自14年的听云报告</a><br>根据统计数据显示，当iOS的崩溃率超过0.8%，Android的崩溃率超过0.4%的时候，活跃用户有明显下降态势。</td>    </tr>    <tr>        <td>2.96%</td>         <td>2.86%</td>         <td ><a href= "https://blog.csdn.net/f2006116/article/details/55504714">bugly2016 移动应用质量大数据报告-平均崩溃率</a></td>    </tr>    <tr>        <td colspan="2">优秀：0.03%</td>          <td>一些开发群中开发者的回复（滴滴，美团）</td>     </tr>    <tr>        <td nowrap="nowrap">ANR率/卡顿率</td>         <td>-</td>         <td>1.09%</td>         <td>GooglePlay的不良行为门槛</td>     </tr>    <tr>        <td>用户ANR率</td>         <td>-</td>         <td>0.47%</td>         <td>GooglePlay的不良行为门槛</td>     </tr>    <tr>        <td>启动时间</td>         <td colspan="2">5s</td>        <td>Performance标准值</td>     </tr>    <tr>        <td>網路呼叫成功率</td>         <td>97.45%</td>         <td>95.48%</td>         <td>听云17年报告 - 年平均 HTTP 请求成功率</td>     </tr>    <tr>        <td rowspan="2">响应时间</td>         <td>417.99ms</td>         <td>439.65ms</td>         <td>听云17年报告 - 房产中介 - 年平均响应时间</td>     </tr>    <tr>        <td>652.69ms</td>         <td>617.19ms</td>         <td>听云17年报告 - 工具 - 年平均响应时间</td>     </tr></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><h3 id="友盟定义参考"><a href="#友盟定义参考" class="headerlink" title="友盟定义参考"></a>友盟定义参考</h3><ul><li><a href="https://developer.umeng.com/docs/67953/detail/67989#h1-u542Fu52A8u6B21u65703" target="_blank" rel="noopener">用户描述文档：</a></li><li><a href="https://developer.umeng.com/docs/67953/detail/68133" target="_blank" rel="noopener">错误描述文档：</a></li></ul><h3 id="Bugly定义参考"><a href="#Bugly定义参考" class="headerlink" title="Bugly定义参考"></a>Bugly定义参考</h3><ul><li><a href="https://bugly.qq.com/docs/introduction/bugly-introduction/?v=20180709165613#_6" target="_blank" rel="noopener">描述文档：</a></li></ul><h3 id="Preformace"><a href="#Preformace" class="headerlink" title="Preformace"></a>Preformace</h3><ul><li><a href="https://support.google.com/firebase/answer/6318039?hl=zh-Hans" target="_blank" rel="noopener">Firebase 性能监控的数据收集</a></li></ul><h3 id="听云"><a href="#听云" class="headerlink" title="听云"></a>听云</h3><ul><li><a href="https://www.tingyun.com/awr_mobile.html" target="_blank" rel="noopener">听云移动应用性能管理白皮书</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这个月Boss需要我们整理一份各个性能采集后的参考值，对于崩溃的数据采集，我们接入有Bugly,友盟。对于性能采集
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Firebase的使用集合</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2018/11/21/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2018/11/21/Firebase%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/</id>
    <published>2018-11-21T11:03:03.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Firebase"><a href="#Firebase" class="headerlink" title="Firebase"></a>Firebase</h1><blockquote><p>Firebase是一家实时后端数据库创业公司，它能帮助开发者很快的写出Web端和移动端的应用。自2014年10月Google收购Firebase以来，用户可以在更方便地使用Firebase的同时，结合<a href="https://firebase.google.cn/" target="_blank" rel="noopener">Google的云服务</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为我们公司是用户群是在台湾，所以在第三方库的选型上选择了Firebase。因为它拥有较丰富的第三方库集。</p><h2 id="基础接入"><a href="#基础接入" class="headerlink" title="基础接入"></a>基础接入</h2><ol><li>创建Firebase开发者账户<a href="https://www.firebase.com/login/" target="_blank" rel="noopener">注册地址</a></li><li>安装Firebase.framework<br>通过Cocopod 安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;Firebase&#x2F;Core&#39;</span><br></pre></td></tr></table></figure></li><li>添加Firebase配置文件 <a href="https://firebase.google.com/docs/ios/setup?authuser=0" target="_blank" rel="noopener">将 Firebase 添加到您的 iOS 项目</a></li></ol><ul><li>在控制台中创建项目后，下载配置文件GoogleService-Info.plist，移动加入项目中</li><li>在didFinishLaunchingWithOptions 初始化firebase</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FIRApp configure];</span><br></pre></td></tr></table></figure><h4 id="目前支持Firebase服务有"><a href="#目前支持Firebase服务有" class="headerlink" title="目前支持Firebase服务有"></a>目前支持Firebase服务有</h4><table><thead><tr><th>pod</th><th>服务</th></tr></thead><tbody><tr><td>pod ‘Firebase/Core’</td><td>必备库和 Analytics</td></tr><tr><td>pod ‘Firebase/AdMob’</td><td>AdMob</td></tr><tr><td>pod ‘Firebase/Messaging’</td><td>必备库和 Analytics</td></tr><tr><td>pod ‘Firebase/AdMob’</td><td>AdMob</td></tr><tr><td>pod ‘Firebase/Database’</td><td>实时数据库</td></tr><tr><td>pod ‘Firebase/Invites’</td><td>邀请</td></tr><tr><td>pod ‘Firebase/DynamicLinks’</td><td>动态链接</td></tr><tr><td>pod ‘Fabric’，pod ‘Crashlytics’</td><td>Crashlytics</td></tr><tr><td>pod ‘Firebase/RemoteConfig’</td><td>远程配置</td></tr><tr><td>pod ‘Firebase/Auth’</td><td>身份验证</td></tr><tr><td>pod ‘Firebase/Storage’</td><td>存储</td></tr><tr><td>pod ‘Firebase/Performance’</td><td>性能监控</td></tr><tr><td>pod ‘Firebase/Firestore’</td><td>Cloud Firestore</td></tr><tr><td>pod ‘Firebase/Functions’</td><td>Cloud Functions for Firebase 客户端 SDK</td></tr><tr><td>pod ‘Firebase/MLVision’</td><td>ML Kit Vision API</td></tr><tr><td>pod ‘Firebase/MLVisionLabelModel’</td><td>机器学习套件（基于设备的标签检测）</td></tr><tr><td>pod ‘Firebase/MLVisionBarcodeModel’</td><td>机器学习套件（基于设备的条形码扫描）</td></tr><tr><td>pod ‘Firebase/MLVisionTextModel’</td><td>机器学习套件（基于设备的文字识别）</td></tr><tr><td>pod ‘Firebase/MLVisionFaceModel’</td><td>机器学习套件（基于设备的面部检测）</td></tr></tbody></table><h2 id="基于Firebase下的GA统计"><a href="#基于Firebase下的GA统计" class="headerlink" title="基于Firebase下的GA统计"></a>基于Firebase下的GA统计</h2><p>1.配合GTM SDK 将firebase采集到的数据发送到Google Analytics中</p><blockquote><p>添加GTM SDK 与 Google Analytics SDK</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;GoogleIDFASupport&#39;  &#x2F;&#x2F; Google Analytics </span><br><span class="line">pod &#39;GoogleTagManager&#39;   &#x2F;&#x2F; GTM SDK</span><br></pre></td></tr></table></figure><ul><li>登录GTM的平台 <a href="https://tagmanager.google.com/?hl=zh_CN#/org/xM83TFWlQfiVaBKyzHY6Zw" target="_blank" rel="noopener">地址</a></li></ul><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/1.png" alt=""></p><ul><li>创建触发器</li></ul><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/2.png" alt=""></p><ul><li>创建代码  GA-ID变量即是 我们的Google Analytics平台的ID</li></ul><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/3.png" alt=""></p><blockquote><p>简述：我们先在 GTM container 网页上设定想追踪的 tag（标籤），每个 tag 会包含一个 trigger（触发条件），当 Firebase 发送事件后 GTM 会去比对这个事件是不是符合某个 tag 的触发条件，在这次的例子中就会将数据发送到 GA 报表上。触发条件比较灵活，可以自定义。包括维度的划分。这里就不再详细介绍。</p></blockquote><blockquote><p>firebase的发送函数是</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;触发器事件名称</span><br><span class="line">#define Event_Trigger    @&quot;event_trigger_str&quot;</span><br><span class="line">&#x2F;&#x2F; 统计类别</span><br><span class="line">#define Event_Category    @&quot;event_category_str&quot;</span><br><span class="line">&#x2F;&#x2F; 统计动作</span><br><span class="line">#define Event_Action    @&quot;event_action_str&quot;</span><br><span class="line">&#x2F;&#x2F; 统计标签</span><br><span class="line">#define Event_Label    @&quot;event_label_str&quot;</span><br><span class="line">              </span><br><span class="line">&#x2F;&#x2F; 即可将统计事件发送到GA中              </span><br><span class="line">+ (void)fireBaseEvent:(NSString *)category</span><br><span class="line">               action:(NSString *)action</span><br><span class="line">                label:(NSString *)label&#123;</span><br><span class="line">    [FIRAnalytics logEventWithName:Event_Param_Trigger parameters:@&#123;Event_Param_Category:category,Event_Param_Action:action,Event_Param_Label:label&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FCM推送"><a href="#FCM推送" class="headerlink" title="FCM推送"></a>FCM推送</h2><ol><li>通过cocopod库设置Fcm sdk, fcm 中支持<a href="https://firebase.google.com/docs/cloud-messaging/concept-options?authuser=0" target="_blank" rel="noopener">通知消息和数据消息</a></li><li>在”专案设置-设置-Cloud Messaging”中上传开发者凭证到fcm平台</li></ol><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/4.png" alt=""></p><ol start="3"><li>配置代码如下</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过Cocopod导入</span><br><span class="line">pod &#39;Firebase&#x2F;Messaging&#39;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一步设置代理</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;</span><br><span class="line">    &#x2F;&#x2F;配置FCM 代理</span><br><span class="line">    [FIRMessaging messaging].delegate &#x3D; self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">    [self disconnectToFCM];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application&#123;</span><br><span class="line">    [self connectToFCM];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册TOKEN</span><br><span class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken&#123;</span><br><span class="line">   #if DEBUG</span><br><span class="line">    [[FIRMessaging messaging] setAPNSToken:deviceToken type:FIRMessagingAPNSTokenTypeSandbox];</span><br><span class="line">    #else</span><br><span class="line">    [[FIRMessaging messaging] setAPNSToken:deviceToken type:FIRMessagingAPNSTokenTypeProd];</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - RemoteMessage Connect</span><br><span class="line">&#x2F;&#x2F; 链接fcm</span><br><span class="line">- (void)connectToFCM&#123;</span><br><span class="line">    NSString *refreshedToken &#x3D; [[FIRInstanceID instanceID] token];</span><br><span class="line">    DLog(@&quot;InstanceID token: %@&quot;, refreshedToken);</span><br><span class="line">    [FIRMessaging messaging].shouldEstablishDirectChannel &#x3D; YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 断开fcm</span><br><span class="line">- (void)disconnectToFCM&#123;</span><br><span class="line">    [FIRMessaging messaging].shouldEstablishDirectChannel &#x3D; NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark - FIRMessagingRemoteMessage Delegate</span><br><span class="line">&#x2F;&#x2F;获取fcmtoken回调函数</span><br><span class="line">- (void)messaging:(nonnull FIRMessaging *)messaging didReceiveRegistrationToken:(nonnull NSString *)fcmToken&#123;</span><br><span class="line">    DLog(@&quot;didReceiveRegistrationToken fcmToken &#x3D; %@&quot;,fcmToken);</span><br><span class="line">    [self connectToFCM];</span><br><span class="line">    &#x2F;&#x2F; 注意 将fcm 发送到自己的后端采集token及用户的设备id,用于发送推送</span><br><span class="line">    &#x2F;&#x2F; .......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意：fcm data 数据消息的接收回调，如果是通知消息回调，走的是Apple 的api此处不详述</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ios10 之前didReceiveRegistrationToken</span><br><span class="line">- (void)applicationReceivedRemoteMessage:(nonnull FIRMessagingRemoteMessage *)remoteMessage&#123;</span><br><span class="line">    DLog(@&quot;RemoteMessageDeleagte remoteMessage &#x3D; %@&quot;,remoteMessage);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;iOS10 及之后</span><br><span class="line">- (void)messaging:(nonnull FIRMessaging *)messaging didReceiveMessage:(nonnull FIRMessagingRemoteMessage *)remoteMessage&#123;</span><br><span class="line">    DLog(@&quot;RemoteMessageDeleagte didReceiveMessage &#x3D; %@&quot;,remoteMessage);&#x2F;&#x2F;fcm data 数据没有带前缀gcm.notification.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Performace监控"><a href="#Performace监控" class="headerlink" title="Performace监控"></a>Performace监控</h2><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/5.png" alt=""></p><p>firebase 的performance能采集到数据有<a href="https://support.google.com/firebase/answer/6318039?hl=zh-Hans" target="_blank" rel="noopener">链接</a></p><ul><li>启动速度</li><li>网络呼叫成功率</li><li>網路回應 MIME 類型</li><li>網路回應延遲時間</li><li>不同畫面的顯示速度緩慢資料 （可以自定义采集内容）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过Cocopod导入</span><br><span class="line">pod &#39;Firebase&#x2F;Performance&#39;</span><br></pre></td></tr></table></figure><blockquote><p>performance 只要解决导入库,即可。默认会在[FIRApp configure]; 已初始化</p></blockquote></li></ul><h4 id="关于自定义采集-page-speed"><a href="#关于自定义采集-page-speed" class="headerlink" title="关于自定义采集 page_speed"></a>关于自定义采集 page_speed</h4><p><img src="https://zeqinjie.github.io/images/2018/Firebase%E7%9A%84%E4%BD%BF%E7%94%A8%E9%9B%86%E5%90%88/6.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自定义采集是通过setValue:forAttribute 方式设置采集属性及值</span><br><span class="line">+ (void)performaceLoadTimeWithName:(NSString *)name comeDate:(NSDate *)comeDate&#123;</span><br><span class="line">        FIRTrace *trace &#x3D; [FIRPerformance startTraceWithName:name];</span><br><span class="line">        NSTimeInterval time &#x3D; fabs([comeDate timeIntervalSinceNow]);</span><br><span class="line">        [trace setValue:[NSString stringWithFormat:@&quot;%.2f秒&quot;,time] forAttribute:@&quot;page_speed&quot;];</span><br><span class="line">        DLog(@&quot;PageName &#x3D; %@,时间差(秒) &#x3D; %.2f&quot;,name,time);</span><br><span class="line">        [trace stop];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Firebase&quot;&gt;&lt;a href=&quot;#Firebase&quot; class=&quot;headerlink&quot; title=&quot;Firebase&quot;&gt;&lt;/a&gt;Firebase&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Firebase是一家实时后端数据库创业公司，它能帮助开发者很快的
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>公司夺旗比赛-iOS题</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2018/11/21/%E5%85%AC%E5%8F%B8%E5%A4%BA%E6%97%97%E6%AF%94%E8%B5%9B-iOS%E9%A2%98/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2018/11/21/%E5%85%AC%E5%8F%B8%E5%A4%BA%E6%97%97%E6%AF%94%E8%B5%9B-iOS%E9%A2%98/</id>
    <published>2018-11-21T11:02:59.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>公司每年的6月份会举办一场夺旗大赛，作为读书会的小组成员。我就负责出了一份比较简单的iOS题<br><a href="https://juejin.im/post/5bf4b76af265da61602c8ddd" target="_blank" rel="noopener">掘金地址</a></p></blockquote><h2 id="CTF移动端题目"><a href="#CTF移动端题目" class="headerlink" title="CTF移动端题目"></a>CTF移动端题目</h2><h3 id="1-灰原同学提出可以查看监控，但监控室的门是用密码锁上的，门上只有了一串英文字母MjM4MzIxNDE0Mg-你可以帮助少年侦探团打开门吗？"><a href="#1-灰原同学提出可以查看监控，但监控室的门是用密码锁上的，门上只有了一串英文字母MjM4MzIxNDE0Mg-你可以帮助少年侦探团打开门吗？" class="headerlink" title="1.灰原同学提出可以查看监控，但监控室的门是用密码锁上的，门上只有了一串英文字母MjM4MzIxNDE0Mg==,你可以帮助少年侦探团打开门吗？"></a>1.灰原同学提出可以查看监控，但监控室的门是用密码锁上的，门上只有了一串英文字母MjM4MzIxNDE0Mg==,你可以帮助少年侦探团打开门吗？</h3><h5 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">base64解码得到2383214142 </span><br><span class="line">通过手机键盘-九宫格得到</span><br><span class="line">答案 CVAGH</span><br></pre></td></tr></table></figure><h3 id="2-在暗格门里发现作案者留下的文件包，但是却需要账户和密码才能打开，通过下面的代码和文件你能帮助柯南找出答案吗？"><a href="#2-在暗格门里发现作案者留下的文件包，但是却需要账户和密码才能打开，通过下面的代码和文件你能帮助柯南找出答案吗？" class="headerlink" title="2.在暗格门里发现作案者留下的文件包，但是却需要账户和密码才能打开，通过下面的代码和文件你能帮助柯南找出答案吗？"></a>2.在暗格门里发现作案者留下的<a href="https://pan.baidu.com/s/1nxddHhFBr8BjTJkoZn5a-w" target="_blank" rel="noopener">文件包</a>，但是却需要账户和密码才能打开，通过下面的代码和文件你能帮助柯南找出答案吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@interface MyAccount : NSObject </span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *flag;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyAccount</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h5 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1、.m文件实现NSCoding协议，补充代码如下</span><br><span class="line"></span><br><span class="line">#import &quot;MyAccount.h&quot;</span><br><span class="line">@interface MyAccount()&lt;NSCoding&gt;</span><br><span class="line">@end</span><br><span class="line">@implementation MyAccount</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder&#123;</span><br><span class="line">    [aCoder encodeObject:self.flag forKey:@&quot;flag&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithCoder:(NSCoder *)decoder &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        _flag &#x3D; [decoder decodeObjectForKey:@&quot;flag&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、导入data包，NSKeyedUnarchiver解档对象，得到flag: c2h1aXJ1aWtlamljdGY&#x3D;</span><br><span class="line"></span><br><span class="line">NSString *dataFile &#x3D; [[NSBundle mainBundle]pathForResource:@&quot;data&quot; ofType:@&quot;asd&quot;];</span><br><span class="line">MyAccount *model &#x3D; [NSKeyedUnarchiver unarchiveObjectWithFile:dataFile];</span><br><span class="line">NSLog(@&quot;dataFile &#x3D; %@&quot;,model.flag);</span><br><span class="line"></span><br><span class="line">3、使用base64解码得到</span><br><span class="line">答案： shuiruikejictf</span><br></pre></td></tr></table></figure><h3 id="3-侦探少年团解答出账户和密码后并打开文件包后，发现盗贼留下了一份挑战书“你想要的密码就在我的ipa包中”，你能从MySercretKey-ipa包中读取到答案吗？"><a href="#3-侦探少年团解答出账户和密码后并打开文件包后，发现盗贼留下了一份挑战书“你想要的密码就在我的ipa包中”，你能从MySercretKey-ipa包中读取到答案吗？" class="headerlink" title="3.侦探少年团解答出账户和密码后并打开文件包后，发现盗贼留下了一份挑战书“你想要的密码就在我的ipa包中”，你能从MySercretKey.ipa包中读取到答案吗？"></a>3.侦探少年团解答出账户和密码后并打开文件包后，发现盗贼留下了一份挑战书“你想要的密码就在我的ipa包中”，你能从<a href="https://pan.baidu.com/s/1YiNuM3bLXj4-C_2jUsU9Gw" target="_blank" rel="noopener">MySercretKey.ipa</a>包中读取到答案吗？</h3><h5 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h5><pre><code>使用Hopper Disassembler工具反编译如下图读取到flag = U2FsdGVkX18wjamzHeMlywW3nE/EPSImPYlN25ihcf0=decode = shurui使用AES 解密（密钥shurui）答案:flag = asdxczcsa</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;公司每年的6月份会举办一场夺旗大赛，作为读书会的小组成员。我就负责出了一份比较简单的iOS题&lt;br&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
      <category term="addcn" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/addcn/"/>
    
  </entry>
  
  <entry>
    <title>OC和Swift混编经验</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2018/09/10/OC%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E7%BB%8F%E9%AA%8C/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2018/09/10/OC%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E7%BB%8F%E9%AA%8C/</id>
    <published>2018-09-10T11:03:02.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swift简介"><a href="#Swift简介" class="headerlink" title="Swift简介"></a>Swift简介</h2><blockquote><p>Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可与Objective-C*共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。<br>2015年12月4日，苹果公司宣布其Swift编程语言现在开放<a href="https://github.com/apple/swift" target="_blank" rel="noopener">源代码</a>。<br><a href="https://juejin.im/post/5b9650c35188255c8a05dd94" target="_blank" rel="noopener">掘金地址</a></p></blockquote><h2 id="Swift-优势"><a href="#Swift-优势" class="headerlink" title="Swift 优势"></a>Swift 优势</h2><h3 id="简洁代码"><a href="#简洁代码" class="headerlink" title="简洁代码"></a>简洁代码</h3><blockquote><ol><li>Swift所有的变量定义使用var ,常量定义使用let。</li><li>数组或字符串可以使用”+”符号直接相加。</li><li>可以使用高阶函数map，flatMap，reduce，filter简化代码量。</li></ol></blockquote><h3 id="易维护"><a href="#易维护" class="headerlink" title="易维护"></a>易维护</h3><blockquote><ol><li>Swift抛弃了OC头文件（.h）和实现文件（.m）组合成一个代码文件（.swift）。</li><li>因为Swift不是基于C构建的，而OC是在C和Smalltalk下构建。所以在设计上比较新颖，同时我们能看到现代语言（JavaScript，Java，Python，C#，以及 C++ ）的身影特性：泛型，可选类型，类型推断，高阶函数。基于泛型和高阶函数的使用导致更清晰，更可重用的代码，更易于维护。</li></ol></blockquote><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><blockquote><ol><li>在OC中不同类型可以直接相加，默认会隐式转换。但是swift不同类型的是不能直接相加，必须先进行类型转换。</li><li>在其他的编程语言当中，你并不能知道哪个变量可以为空(null)哪个不能，这就强制开发者去考虑可能为空的情况。</li><li>在OC中if判断存在非0即是true的方式，但是在swift中if判断必须为true或者false。</li></ol></blockquote><h3 id="快"><a href="#快" class="headerlink" title="快"></a>快</h3><blockquote><ol><li>OC是一门动态的语言，很多实际执行需要在运行时才可以确定，Swift不一样，Swift将很多在运行时才可以确定的信息，在编译期就决定了。这就让Swift更加快速。<a href="https://onevcat.com/2016/02/swift-performance/" target="_blank" rel="noopener">Swift性能探索和优化分析-王巍</a></li><li>在纯Swift中的函数调用就不是OC的那套runtime了，而是类似C++的vtable，在编译期就决定调用哪个函数。那如果想使用OC的特性需要继承自NSObject。</li></ol></blockquote><h2 id="Swift-与-OC-的混编"><a href="#Swift-与-OC-的混编" class="headerlink" title="Swift 与 OC 的混编"></a>Swift 与 OC 的混编</h2><blockquote><ol><li>当我们在OC项目中添加Swift文件的时候系统会默认帮我创建一个桥接文件。<br>“项目名称-Bridging-Header.h”的文件。</li><li>在Swift中调用OC的类时，只需要在上面桥接头文件import即可</li><li>在OC中调用Swift类，则需在OC文件中import “项目名称-Swift.h” 头文件即可</li></ol></blockquote><h2 id="混合开发的问题"><a href="#混合开发的问题" class="headerlink" title="混合开发的问题"></a>混合开发的问题</h2><blockquote><p>最近有个新闻列表改版需求，那在此下使用Swift去重做这块需求，需求中遇到一些坑和大家分享下。</p></blockquote><ul><li>数模转换的坑<blockquote><p> 在OC项目中常用的MJExtension第三方库。那在swift中我们怎么做呢？<br>当然可以使用目前第三方库SwiftJson或者HandyJSON或者实现Codable协议。不过这里我使用的是系统KVC方式,遇到问题如下</p><ol><li>因为swift的构造函数与OC不一样，当子类中有自己的构造函数时，那么将不继承父类自定义的构造函数。所以子类需重写父类init(dict : [String : Any])这个构造函数否则将无法使用。</li><li>因为使用的是NSObject的KVC特性所以需加@objc定义子类属性。注意在swift4.0之前默认只要继承NSObject就会系统默认添加，但这之后需要手动添加了。</li></ol></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class BaseModel: NSObject &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(dict : [String : Any]) &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        setValuesForKeys(dict)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;记得重写该方法避免崩溃</span><br><span class="line">    override func setValue(_ value: Any?, forUndefinedKey key: String) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class NewsNavModel: BaseModel &#123;</span><br><span class="line">    &#x2F;&#x2F;type &#x3D; 998 最新,999 收藏</span><br><span class="line">    @objc var type:Int &#x3D; 0</span><br><span class="line">    @objc var type_name:String &#x3D; &quot;&quot;</span><br><span class="line">    </span><br><span class="line">    init(_ type : Int , type_name : String) &#123;</span><br><span class="line">        super.init()</span><br><span class="line">        self.type &#x3D; type</span><br><span class="line">        self.type_name &#x3D; type_name</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;需重写父类方法</span><br><span class="line">    override init!(dic: [String : Any]!) &#123;</span><br><span class="line">        super.init(dic: dic)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>关于@objc坑</p><blockquote><ol><li>在swift3使用#selector指定的方法，只有当方法权限为private时需要加@objc修饰符，现在Swift4.0全都要加@objc修饰符</li><li>定义的方法，枚举，协议或者是属性如果需要被OC调用则需添加@objc</li><li>自定义的protocol协议中,有optional修饰的非必须实现的方法,需要用@objc修饰</li></ol></blockquote></li><li><p>被废弃的方法:</p><blockquote><p>initialize/dispatch_once方法已经被Swift4.0废弃所以后续不能再使用</p></blockquote></li><li><p>NSClassFromString方法的坑</p><blockquote><p>在OC的时候直接使用类名即可转换为对于Class，但是Swift中有命名空间存在所以使用这个方法需要添加项目的名称</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;OC 中</span><br><span class="line">Class ocClass &#x3D; NSClassFromString(@&quot;MyFavModel&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Swift中</span><br><span class="line">let swiftClass &#x3D; NSClassFromString(&quot;项目名称.MyFavModel&quot;)</span><br></pre></td></tr></table></figure><ul><li><p>fatalError</p><blockquote><p>在Swift 中继承了遵守NSCoding protocol的类时，并自定义构造函数时候则需加入required init(coder aDecoder: NSCoder)。这个是在OC中则不存在的。<br>其作用是表明子类不能通过被fatalError定义的函数做初始化</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) &#123;</span><br><span class="line">    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)</span><br><span class="line">    self.hidesBottomBarWhenPushed &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">required init(coder aDecoder: NSCoder) &#123;</span><br><span class="line">    fatalError(&quot;init(coder:) has not been implemented&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OC的类不能继承至Swift的类，但是Swift类可以继承至OC的类。</p><blockquote><p>补充：即使Swift的父类是OC也不能让OC类继承该Swift类</p></blockquote></li><li><p>Swift中没有宏，只能使用全局常量或者全局函数替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 当前app信息</span><br><span class="line">let AppInfo &#x3D; Bundle.main.infoDictionary</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 当前app版本号</span><br><span class="line">let AppCurrentVersion &#x3D; Bundle.main.object(forInfoDictionaryKey: &quot;CFBundleShortVersionString&quot;) as! String</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 日志打印</span><br><span class="line">func DLog(str: String) &#123;</span><br><span class="line">    #if DEBUG</span><br><span class="line">    print(&quot;file: \(#file), line:\(#line),\(str)&quot;)</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Swift不像OC那样能直接调用C++,需通过OC或者C去调用C++。</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Swift版本升级"><a href="#Swift版本升级" class="headerlink" title="Swift版本升级"></a>Swift版本升级</h3><blockquote><p>例如:Swift3.0 -&gt; Swift4.0</p><ol><li>选中要转换的 target</li><li>Edit -&gt; Convert -&gt; To Current Swift Syntax </li><li>勾选需要转换的 target （pod 引用不用勾选），Next </li><li>选择转换选项，Next </li></ol></blockquote><p><img src="https://zeqinjie.github.io/images/2018/OC%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E7%BB%8F%E9%AA%8C/1.png" alt=""></p><h3 id="快速的将OC语言转换成Swift语言"><a href="#快速的将OC语言转换成Swift语言" class="headerlink" title="快速的将OC语言转换成Swift语言"></a>快速的将OC语言转换成Swift语言</h3><blockquote><p>这里推荐一款swiftify插件。支持在线转换，或者添加插件到Xcode中。</p><ol><li><a href="https://itunes.apple.com/cn/app/swiftify-objective-c-converter-for-xcode/id1183412116?mt=12" target="_blank" rel="noopener">插件安装AppStore下载地址</a></li><li><a href="https://objectivec2swift.com/#/home" target="_blank" rel="noopener">在线转换地址</a></li></ol></blockquote><p><img src="https://zeqinjie.github.io/images/2018/OC%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E7%BB%8F%E9%AA%8C/2.png" alt=""></p><h3 id="快速将json转化为Swift的模型对象"><a href="#快速将json转化为Swift的模型对象" class="headerlink" title="快速将json转化为Swift的模型对象"></a>快速将json转化为Swift的模型对象</h3><blockquote><p>基于Codable协议快速的数模序列化</p><ol><li>它不仅支持Swift,还支持其他语言比如Kotlin,Java,C#,Ruby,Object-c,Python</li><li><a href="https://app.quicktype.io/" target="_blank" rel="noopener">在线链接</a></li></ol></blockquote><p><img src="https://zeqinjie.github.io/images/2018/OC%E5%92%8CSwift%E6%B7%B7%E7%BC%96%E7%BB%8F%E9%AA%8C/3.png" alt=""></p><h3 id="通过R-swift快速生成资源代码"><a href="#通过R-swift快速生成资源代码" class="headerlink" title="通过R.swift快速生成资源代码"></a>通过R.swift快速生成资源代码</h3><p>根据项目内容来自动化生 ImageName 和 SegueName代码 可以使用Switf的自动化工具了，<a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a> 和 <a href="https://github.com/SwiftGen/SwiftGen" target="_blank" rel="noopener">SwiftGen</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let image &#x3D; UIImage(imageName: .imgIcon)</span><br></pre></td></tr></table></figure><h3 id="Swift-测试速度"><a href="#Swift-测试速度" class="headerlink" title="Swift 测试速度"></a>Swift 测试速度</h3><ul><li><a href="https://www.jessesquires.com/blog/apples-to-apples-part-two/" target="_blank" rel="noopener">Swift 与 Object-C的速度测试对比</a></li><li><a href="https://www.jessesquires.com/blog/apples-to-apples-part-three/" target="_blank" rel="noopener">Swift 与 C的速度测试对比</a></li></ul><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><blockquote><p>Swift学习文档：</p><ol><li><a href="https://link.jianshu.com/?t=https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309" target="_blank" rel="noopener">The Swift Programming Language (Swift 4)</a></li><li><a href="https://github.com/apple/swift-evolution/tree/master/proposals" target="_blank" rel="noopener">Swift的180个介绍</a></li></ol></blockquote><blockquote><p>Swift 书籍 </p><ol><li><a href="http://swifter.tips/buy" target="_blank" rel="noopener">Swifter - Swift 必备 tips</a></li><li><a href="https://www.objccn.io/products/advanced-swift/" target="_blank" rel="noopener">Swift 进阶</a></li></ol></blockquote><blockquote><p>参考地址</p><ol><li><a href="https://www.cnblogs.com/baitongtong/p/7250940.html" target="_blank" rel="noopener">Swift4.0新特性</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Swift简介&quot;&gt;&lt;a href=&quot;#Swift简介&quot; class=&quot;headerlink&quot; title=&quot;Swift简介&quot;&gt;&lt;/a&gt;Swift简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Swift，苹果于2014年WWDC（苹果开发者大会）发布的新开发语言，可
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS怎么推送统计到达率</title>
    <link href="https://vigilant-lovelace-ee6cb4.netlify.app/2018/07/04/iOS%E6%80%8E%E4%B9%88%E6%8E%A8%E9%80%81%E7%BB%9F%E8%AE%A1%E5%88%B0%E8%BE%BE%E7%8E%87/"/>
    <id>https://vigilant-lovelace-ee6cb4.netlify.app/2018/07/04/iOS%E6%80%8E%E4%B9%88%E6%8E%A8%E9%80%81%E7%BB%9F%E8%AE%A1%E5%88%B0%E8%BE%BE%E7%8E%87/</id>
    <published>2018-07-04T11:03:02.000Z</published>
    <updated>2020-07-28T11:40:03.742Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5b3ca2d05188251afe7b66be" target="_blank" rel="noopener">掘金地址</a></p><h2 id="ios摘要"><a href="#ios摘要" class="headerlink" title="ios摘要"></a>ios摘要</h2><ul><li><a href="http://www.cocoachina.com/ios/20170126/18618.html" target="_blank" rel="noopener">iOS10里的通知与推送</a></li><li><a href="https://www.jianshu.com/p/ace1b422bad4" target="_blank" rel="noopener">国内 90%以上的 iOS 开发者，对 APNs 的认识都是错的</a><h2 id="体系图"><a href="#体系图" class="headerlink" title="体系图"></a>体系图</h2><img src="https://zeqinjie.github.io/images/2018/iOS%E6%80%8E%E4%B9%88%E6%8E%A8%E9%80%81%E7%BB%9F%E8%AE%A1%E5%88%B0%E8%BE%BE%E7%8E%87/1.png" alt=""></li></ul><h2 id="直接进入正题如何统计到达"><a href="#直接进入正题如何统计到达" class="headerlink" title="直接进入正题如何统计到达"></a>直接进入正题如何统计到达</h2><h3 id="在iOS10中新增两个拓展"><a href="#在iOS10中新增两个拓展" class="headerlink" title="在iOS10中新增两个拓展"></a>在iOS10中新增两个拓展</h3><ol><li>其中的一个拓展UNNotificationServiceExtension 通知服务扩展</li></ol><ul><li>UNNotificationServiceExtension 是修改远程推送携带的内容。</li><li>UNNotificationServiceExtension 类 可以让开发者自定义推送展示的内容。你可以用 extension 修改推送内容和下载推送相关的资源。你可以在extension 中解密和加密的数据或下载推送相关的图片</li></ul><p>2.因此在这里可以提交到达的请求注意是这里处理时间只有30秒。为了不影响达到统计接口。一般会先发统计请求。同时通过缓存减少图片的请求。及图片的大小处理。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NotificationService</span> ()&lt;<span class="title">NSURLSessionDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">void</span> (^contentHandler)(UNNotificationContent *contentToDeliver);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) UNMutableNotificationContent *bestAttemptContent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NotificationService</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(<span class="keyword">void</span> (^)(UNNotificationContent * _Nonnull))contentHandler &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.contentHandler = contentHandler;</span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent = [request.content mutableCopy];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *userInfo = request.content.userInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *iconUrl = userInfo[[<span class="keyword">self</span> fcmPushStrFromStr:<span class="string">@"small_image"</span>]];<span class="comment">//小图</span></span><br><span class="line">    <span class="built_in">NSString</span> *imageUrl = userInfo[[<span class="keyword">self</span> fcmPushStrFromStr:<span class="string">@"image"</span>]];<span class="comment">//大图</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重点这里发送给后端到达统计</span></span><br><span class="line">    [ProfessionTool sendFcmPushStatUserInfo:userInfo];<span class="comment">//统计到达数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里是处理富文本图片 ，媒体视频等</span></span><br><span class="line">    UNNotificationAttachment *iconAtt = [<span class="keyword">self</span> attachmentWithUrl:iconUrl fileName:<span class="string">@"small_image"</span>];<span class="comment">//待优化缓存方式</span></span><br><span class="line">    UNNotificationAttachment *imageAtt = [<span class="keyword">self</span> attachmentWithUrl:imageUrl fileName:<span class="string">@"image"</span>];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *attArr = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">if</span> (iconAtt) [attArr addObject:iconAtt];</span><br><span class="line">    <span class="keyword">if</span> (imageAtt) [attArr addObject:imageAtt];</span><br><span class="line">    <span class="keyword">self</span>.bestAttemptContent.attachments = attArr;</span><br><span class="line">    <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UNNotificationAttachment *)attachmentWithUrl:(<span class="built_in">NSString</span> *)url fileName:(<span class="built_in">NSString</span> *)fileName&#123;</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *iconImg = [<span class="keyword">self</span> getImageFromURL:url];</span><br><span class="line">        <span class="built_in">NSArray</span> *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</span><br><span class="line">        <span class="built_in">NSString</span> *documentsDirectoryPath = [paths firstObject];</span><br><span class="line">        <span class="built_in">NSString</span> *iconPath = [<span class="keyword">self</span> saveImage:iconImg withFileName:fileName ofType:<span class="string">@"png"</span> inDirectory:documentsDirectoryPath];</span><br><span class="line">        <span class="keyword">if</span> (iconPath &amp;&amp; ![iconPath isEqualToString:<span class="string">@""</span>]) &#123;</span><br><span class="line">            UNNotificationAttachment * attachment = [UNNotificationAttachment attachmentWithIdentifier:fileName URL:[<span class="built_in">NSURL</span> URLWithString:[<span class="string">@"file://"</span> stringByAppendingString:iconPath]] options:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line">            <span class="keyword">if</span> (attachment) &#123;</span><br><span class="line">                <span class="keyword">return</span> attachment;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)serviceExtensionTimeWillExpire &#123;</span><br><span class="line">    <span class="comment">// Called just before the extension will be terminated by the system.</span></span><br><span class="line">    <span class="comment">// Use this as an opportunity to deliver your "best attempt" at modified content, otherwise the original push payload will be used.</span></span><br><span class="line">    <span class="keyword">self</span>.contentHandler(<span class="keyword">self</span>.bestAttemptContent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - private Method</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *)getImageFromURL:(<span class="built_in">NSString</span> *)fileURL &#123;</span><br><span class="line">    DLog(<span class="string">@"执行图片下载函数"</span>);</span><br><span class="line">    <span class="built_in">UIImage</span> * result;</span><br><span class="line">    <span class="comment">//dataWithContentsOfURL方法需要https连接</span></span><br><span class="line">    <span class="built_in">NSData</span> * data = [<span class="built_in">NSData</span> dataWithContentsOfURL:[<span class="built_in">NSURL</span> URLWithString:fileURL]];</span><br><span class="line">    result = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所下载的图片保存到本地</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)saveImage:(<span class="built_in">UIImage</span> *)image withFileName:(<span class="built_in">NSString</span> *)imageName ofType:(<span class="built_in">NSString</span> *)extension inDirectory:(<span class="built_in">NSString</span> *)directoryPath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *urlStr = <span class="string">@""</span>;</span><br><span class="line">    <span class="keyword">if</span> ([[extension lowercaseString] isEqualToString:<span class="string">@"png"</span>])&#123;</span><br><span class="line">        urlStr = [directoryPath stringByAppendingPathComponent:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.%@"</span>, imageName, <span class="string">@"png"</span>]];</span><br><span class="line">        [<span class="built_in">UIImagePNGRepresentation</span>(image) writeToFile:urlStr options:<span class="built_in">NSAtomicWrite</span> error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([[extension lowercaseString] isEqualToString:<span class="string">@"jpg"</span>] ||</span><br><span class="line">               [[extension lowercaseString] isEqualToString:<span class="string">@"jpeg"</span>])&#123;</span><br><span class="line">        urlStr = [directoryPath stringByAppendingPathComponent:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.%@"</span>, imageName, <span class="string">@"jpg"</span>]];</span><br><span class="line">        [<span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">1.0</span>) writeToFile:urlStr options:<span class="built_in">NSAtomicWrite</span> error:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        DLog(<span class="string">@"extension error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> urlStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因项目中使用google 的FCM推送收到的推送字段有点不一样</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)fcmPushStrFromStr:(<span class="built_in">NSString</span> *)str&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *resultStr = str;</span><br><span class="line">    <span class="built_in">NSString</span> *fcmPre = <span class="string">@"gcm.notification."</span>;</span><br><span class="line">    <span class="keyword">if</span> (![resultStr containsString:fcmPre]) &#123;</span><br><span class="line">        resultStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>,fcmPre,resultStr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.服务端配置内容需要添加”mutable-content”:1 （富文本推送）<br>很多人会搞混”content-available”:1（静默推送）</p><p>4.当然了google FCM的富文本推送是”mutable_content”:”true”<br>国内用的比较多的是激光JPush.百度推送等。后续会写篇google FCM 推送的配置方式</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">拿到的回调内容</span><br><span class="line">&#x2F;&#x2F;iOS10 之前</span><br><span class="line">&#123;</span><br><span class="line">&quot;aps&quot; : &#123;</span><br><span class="line">    &quot;alert&quot; : &quot;title&quot;,</span><br><span class="line">    &quot;badge&quot; : 1,</span><br><span class="line">    &quot;sound&quot;:&quot;default&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;iOS10 新增的文案多样性</span><br><span class="line">&#123;</span><br><span class="line">&quot;aps&quot; : &#123;</span><br><span class="line">    &quot;alert&quot; : &#123; </span><br><span class="line">         &quot;title&quot; : &quot;title&quot;, </span><br><span class="line">         &quot;subtitle&quot; : &quot;subtitle&quot;,         </span><br><span class="line">         &quot;body&quot; : &quot;body&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">    &quot;badge&quot; : 1,</span><br><span class="line">    &quot;sound&quot;:&quot;default&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收到推送回调函数</span></span><br><span class="line"><span class="comment">//iOS1O之前的 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NS_AVAILABLE_IOS(3_0)</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo&#123;</span><br><span class="line">    <span class="comment">//最开始的接收推送回调</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NS_AVAILABLE_IOS(7_0)</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler&#123;</span><br><span class="line">    <span class="comment">//这里亦可接收静默推送回调   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//iOS10之后统一 </span></span><br><span class="line"><span class="comment">//  iOS10特性。App在前台获取通知</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification*)notification withCompletionHandler:(<span class="keyword">void</span> (^)(UNNotificationPresentationOptions options))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">   completionHandler(UNNotificationPresentationOptionAlert);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击通知进入App</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(<span class="keyword">void</span> (^)())completionHandler &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.与之前不同是ios10前台运行也能收到推送通知栏同样在上面userNotificationCenter接收处理点击事件</p><p>6.当然本人曾在低于iOS10版本通用过pod ‘JDStatusBarNotification’库模仿一个推送通知栏</p><p>7.测试发送iOS10的富文本推送低于iOS10版本的的用户只能收到title. subtitle内容是获取不到的。</p><p>8.Target的调试 将项目运行起来，然后发送一条推送之后，激活Service Extension，在XCode -DEBUG下Attach to Process 选择对于的target</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5b3ca2d05188251afe7b66be&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ios摘要&quot;&gt;&lt;a href=&quot;#ios摘要&quot; cla
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://vigilant-lovelace-ee6cb4.netlify.app/tags/iOS/"/>
    
  </entry>
  
</feed>
